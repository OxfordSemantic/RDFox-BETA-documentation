<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>10. Reasoning &mdash; RDFox  documentation</title><link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/ost_theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/dev-favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  <script id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/algoliasearch@4.14.2/dist/algoliasearch-lite.umd.js"></script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/instantsearch.js@4.46.2/dist/instantsearch.production.min.js"></script>
        <script defer="defer" src="_static/algolia.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="11. Transactions" href="transactions.html" />
    <link rel="prev" title="9. Querying" href="querying.html" />
    <!-- Start of HubSpot Cookie Blocking Code -->
    <script type="application/javascript" id="hs-cookie-banner-scan" data-hs-allowed="true" src="https://js.hs-banner.com/cookie-scanning/6485449/4b9c57c39524d7b4a85dd163da87b1d54dc9b0e11f55359272e78d1092aa8d77.js"></script>
    <!-- End of HubSpot Cookie Blocking Code -->

     

    <!-- Set up consent mode for Google Analytics -->
    <!-- Retrieve previous consent settings if present, otherwise deny everything -->
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}

        if(localStorage.getItem('consentMode') === null) {
            gtag('consent', 'default', {
                'ad_storage': 'denied',
                'analytics_storage': 'denied',
                'personalization_storage': 'denied',
                'functionality_storage': 'denied',
                'security_storage': 'denied',
                'ads_data_redaction': true,
            });
        } else {
            gtag('consent', 'default', JSON.parse(localStorage.getItem('consentMode')));
        }
    </script>
    <!-- End of consent mode setup for Google Analytics -->

    <!-- Listen for consent changes from HubSpot consent banner -->
    <script>
        var _hsp = window._hsp = window._hsp || [];
        _hsp.push(['addPrivacyConsentListener', function(consent) {
            const consentMode = {
                'ad_storage': consent.categories.advertisement ? 'granted' : 'denied',
                'analytics_storage': consent.categories.analytics ? 'granted' : 'denied',
                'personalization_storage': consent.categories.advertisement ? 'granted' : 'denied',
                'functionality_storage': consent.categories.functionality ? 'granted' : 'denied',
                'security_storage': consent.categories.functionality ? 'granted' : 'denied',
                'ads_data_redaction': consent.categories.advertisement ? false : true,
            };
            gtag('consent', 'update', consentMode);
            localStorage.setItem('consentMode', JSON.stringify(consentMode))

            // Google Tag Manager
            function addGtm(w,d,s,l,i){
                w[l]=w[l]||[];
                w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});
                var f=d.getElementsByTagName(s)[0];
                var j=d.createElement(s);
                var dl=l!='dataLayer'?'&l='+l:'';
                j.async=true;
                j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;
                f.parentNode.insertBefore(j,f);
            }
            if(
                consent.categories.analytics
                || consent.categories.functionality
                || consent.categories.advertisement
            ) {
                addGtm(window,document,'script','dataLayer','GTM-WFM2Q9D');
            }
            // End of Google Tag Manager code
        }]);
    </script>
    <!-- End of consent listener -->
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption"><span class="caption-text">Introduction</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="welcome-to-rdfox.html">1. Welcome to RDFox</a></li>
<li class="toctree-l1"><a class="reference internal" href="features-and-requirements.html">2. RDFox Features and Requirements</a></li>
<li class="toctree-l1"><a class="reference internal" href="getting-started.html">3. Getting Started</a></li>
</ul>
<p class="caption"><span class="caption-text">Organization of Data</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="servers.html">4. Servers</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-stores.html">5. Data Stores</a></li>
<li class="toctree-l1"><a class="reference internal" href="tuple-tables.html">6. Tuple Tables</a></li>
<li class="toctree-l1"><a class="reference internal" href="data-sources.html">7. Data Sources</a></li>
</ul>
<p class="caption"><span class="caption-text">Functionality</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="import-and-export.html">8. Import and Export</a></li>
<li class="toctree-l1"><a class="reference internal" href="querying.html">9. Querying</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">10. Reasoning</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#rule-languages">10.1. Rule Languages</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datalog">10.1.1. Datalog</a></li>
<li class="toctree-l3"><a class="reference internal" href="#extensions-of-datalog">10.1.2. Extensions of Datalog</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#negation-as-failure">10.1.2.1. Negation-as-failure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#aggregation">10.1.2.2. Aggregation</a></li>
<li class="toctree-l4"><a class="reference internal" href="#built-in-functions">10.1.2.3. Built-in Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#equality">10.1.2.4. Equality</a></li>
<li class="toctree-l4"><a class="reference internal" href="#named-graphs-and-n-ary-relations">10.1.2.5. Named Graphs and N-ary Relations</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#materialization-based-reasoning">10.2. Materialization-Based Reasoning</a></li>
<li class="toctree-l2"><a class="reference internal" href="#restrictions-on-rule-sets">10.3. Restrictions on Rule Sets</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-rule-language-of-rdfox">10.4. The Rule Language of RDFox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#tuple-table-atom">10.4.1. Tuple Table Atom</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#default-graph-atom">10.4.1.1. Default Graph Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#named-graph-atom">10.4.1.2. Named Graph Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="#general-atom">10.4.1.3. General Atom</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#bind-atom">10.4.2. Bind Atom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#filter-atom">10.4.3. Filter Atom</a></li>
<li class="toctree-l3"><a class="reference internal" href="#negation">10.4.4. Negation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#aggregate">10.4.5. Aggregate</a></li>
<li class="toctree-l3"><a class="reference internal" href="#grammar">10.4.6. Grammar</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#common-uses-of-rules-in-practice">10.5. Common Uses of Rules in Practice</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#computing-the-transitive-closure-of-a-relation">10.5.1. Computing the Transitive Closure of a Relation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#composing-relations">10.5.2. Composing Relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#representing-sparql-1-1-property-paths">10.5.3. Representing SPARQL 1.1 Property Paths</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-a-query-as-a-view">10.5.4. Defining a Query as a View</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-calculations-and-aggregating-data">10.5.5. Performing Calculations and Aggregating Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#arranging-concepts-and-relations-in-a-hierarchical-structure">10.5.6. Arranging Concepts and Relations in a Hierarchical Structure</a></li>
<li class="toctree-l3"><a class="reference internal" href="#detecting-cyclic-relations">10.5.7. Detecting Cyclic Relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#defining-attributes-and-relationships-as-mandatory">10.5.8. Defining Attributes and Relationships as Mandatory</a></li>
<li class="toctree-l3"><a class="reference internal" href="#expressing-defaults-and-exceptions">10.5.9. Expressing Defaults and Exceptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#restructuring-data">10.5.10. Restructuring Data</a></li>
<li class="toctree-l3"><a class="reference internal" href="#representing-ordered-relations">10.5.11. Representing Ordered Relations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#representing-equality-cliques">10.5.12. Representing Equality Cliques</a></li>
<li class="toctree-l3"><a class="reference internal" href="#populating-a-knowledge-graph-from-a-data-source">10.5.13. Populating a Knowledge Graph from a Data Source</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#owl-2-support-in-rdfox">10.6. OWL 2 Support in RDFox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#owl-2-ontologies">10.6.1. OWL 2 Ontologies</a></li>
<li class="toctree-l3"><a class="reference internal" href="#owl-2-ontologies-vs-rdfox-rules">10.6.2. OWL 2 Ontologies vs. RDFox Rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-owl-2-ontologies-into-rdfox">10.6.3. Loading OWL 2 Ontologies into RDFox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#associating-ontologies-with-named-graphs">10.6.4. Associating Ontologies with Named Graphs</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-ontologies-from-triples">10.6.5. Loading Ontologies from Triples</a></li>
<li class="toctree-l3"><a class="reference internal" href="#subsumption-reasoning">10.6.6. Subsumption Reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#current-limitations">10.6.7. Current Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#swrl-support-in-rdfox">10.7. SWRL Support in RDFox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#swrl-rules">10.7.1. SWRL Rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#loading-swrl-rules-in-rdfox">10.7.2. Loading SWRL Rules in RDFox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#negation-as-failure-in-swrl">10.7.3. Negation-As-Failure in SWRL</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">10.7.4. Current Limitations</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#explaining-reasoning-results">10.8. Explaining Reasoning Results</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#format-encoding-explanation-of-reasoning">10.8.1. Format Encoding Explanation of Reasoning</a></li>
<li class="toctree-l3"><a class="reference internal" href="#explanation-in-the-web-console">10.8.2. Explanation in the Web Console</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#monitoring-reasoning-in-rdfox">10.9. Monitoring Reasoning in RDFox</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#inspecting-rules-in-rdfox">10.9.1. Inspecting Rules in RDFox</a></li>
<li class="toctree-l3"><a class="reference internal" href="#using-reasoning-monitors-in-rdfox">10.9.2. Using Reasoning Monitors in RDFox</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#the-summary-reasoning-monitor">10.9.2.1. The Summary Reasoning Monitor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#the-reasoning-profiler">10.9.2.2. The Reasoning Profiler</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#querying-the-explicitly-given-data">10.10. Querying the Explicitly given Data</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="transactions.html">11. Transactions</a></li>
<li class="toctree-l1"><a class="reference internal" href="access-control.html">12. Access Control</a></li>
<li class="toctree-l1"><a class="reference internal" href="persistence.html">13. Persistence</a></li>
</ul>
<p class="caption"><span class="caption-text">Interfaces</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="connections.html">14. Connections</a></li>
<li class="toctree-l1"><a class="reference internal" href="rdfox-shell.html">15. RDFox Shell</a></li>
<li class="toctree-l1"><a class="reference internal" href="apis.html">16. APIs</a></li>
<li class="toctree-l1"><a class="reference internal" href="javadoc.html">17. Javadoc</a></li>
</ul>
<p class="caption"><span class="caption-text">Operations Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="rdfox-executable.html">18. RDFox Executable</a></li>
<li class="toctree-l1"><a class="reference internal" href="rdfox-endpoint.html">19. RDFox Endpoint</a></li>
<li class="toctree-l1"><a class="reference internal" href="logging.html">20. Logging</a></li>
<li class="toctree-l1"><a class="reference internal" href="high-availability.html">21. High Availability</a></li>
<li class="toctree-l1"><a class="reference internal" href="docker.html">22. RDFox Docker Images</a></li>
</ul>
<p class="caption"><span class="caption-text">Information</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="release-notes.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="security-advisories.html">Security Advisories</a></li>
<li class="toctree-l1"><a class="reference internal" href="acknowledgments.html">Acknowledgments</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">RDFox</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">10. </span>Reasoning</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="reasoning">
<span id="id1"></span><h1><span class="section-number">10. </span>Reasoning<a class="headerlink" href="#reasoning" title="Permalink to this headline">¶</a></h1>
<p>Reasoning in RDF is the ability to calculate the set of triples that logically
follow from an RDF graph and a set of rules. Such logical consequences are
materialized in RDFox® as new triples in the graph.</p>
<p>The use of rules can significantly simplify the management of RDF data as well
as provide a more complete set of answers to user queries. Consider, for
instance, a graph containing the following triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :oxfordshire .
:oxfordshire :locatedIn :england .
</pre></div>
</div>
<p>The relation <code class="docutils literal notranslate"><span class="pre">:locatedIn</span></code> is intuitively transitive: from the fact that
Oxford is located in Oxfordshire and Oxfordshire is located in England, we can
deduce that Oxford is located in England. The triple <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span>
<span class="pre">:england</span></code> is, however, missing from the graph. As a consequence, SPARQL
queries asking for all English cities will not return <code class="docutils literal notranslate"><span class="pre">:oxford</span></code> as an answer.</p>
<p>We could, of course, add the missing triple by hand to the graph, in which case
<code class="docutils literal notranslate"><span class="pre">:oxford</span></code> would now be returned as an answer to our previous query. Doing so,
however, has a number of important disadvantages. First, there can be millions
such missing triples and each of them would need to be manually added, which is
cumbersome and error-prone; for instance, if we add to the graph the triple
<code class="docutils literal notranslate"><span class="pre">:england</span> <span class="pre">:locatedIn</span> <span class="pre">:uk</span></code>, then the following additional triples should also
be added:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :uk .
:oxfordshire :locatedIn :uk .
</pre></div>
</div>
<p>More importantly, by manually adding missing triples we are not capturing the
transitive nature of the relation, which establishes a causal link between
different triples. Indeed, triple <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:england</span></code> holds because
triples <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:oxfordshire</span></code> and <code class="docutils literal notranslate"><span class="pre">:oxfordshire</span> <span class="pre">:locatedIn</span>
<span class="pre">:england</span></code> are part of the data. Assume that we later find out that <code class="docutils literal notranslate"><span class="pre">:oxford</span></code>
is not located in <code class="docutils literal notranslate"><span class="pre">:oxfordshire</span></code>, but rather in the state of Mississippi in
the US, and we delete from the graph the triple <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span>
<span class="pre">:oxfordshire</span></code> as a result. Then, the triples <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">locatedIn</span> <span class="pre">:england</span></code>
and <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:uk</span></code> should also be retracted as they are no longer
justified. Such situations are very hard to handle manually.</p>
<p>As we will see next, we can use a rule to faithfully represent the transitive
nature of the relation and handle all of the aforementioned challenges in an
efficient and elegant way.</p>
<div class="section" id="rule-languages">
<h2><span class="section-number">10.1. </span>Rule Languages<a class="headerlink" href="#rule-languages" title="Permalink to this headline">¶</a></h2>
<p>A rule language for RDF determines which syntactic expressions are valid rules,
and also provides well-defined meaning to each rule. In particular, given an
arbitrary set of syntactically valid rules and an arbitrary RDF graph, the set
of new triples that follow from the application of the rules to the graph must
be unambiguously defined.</p>
<div class="section" id="datalog">
<h3><span class="section-number">10.1.1. </span>Datalog<a class="headerlink" href="#datalog" title="Permalink to this headline">¶</a></h3>
<p>Rule languages have been in use since the 1980s in the fields of data
management and artificial intelligence. The basic rule language is called
<em>Datalog</em>. It is a very well understood language, which constitutes the core of
a plethora of subsequent rule formalisms equipped with a wide range of
extensions. In this section, we describe Datalog in the context of RDF.</p>
<p>A Datalog rule can be seen as an <code class="docutils literal notranslate"><span class="pre">IF</span> <span class="pre">…</span> <span class="pre">THEN</span></code> statement. In particular, the
following is a Datalog rule which faithfully represents the transitive nature
of the relation <code class="docutils literal notranslate"><span class="pre">:locatedIn</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :locatedIn, ?z] :- [?x, :locatedIn, ?y], [?y, :locatedIn, ?z] .
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">IF</span></code> part of the rule is also called the <em>body</em> or <em>antecedent</em>; the
<code class="docutils literal notranslate"><span class="pre">THEN</span></code> part of the rule is called the <em>head</em> or the <em>consequent</em>. The head is
written first and is separated from the body by the symbol <code class="docutils literal notranslate"><span class="pre">:-</span></code>. Both body
and head consist of a conjunction of conditions, where conjuncts are
comma-separated and where each conjunct is a triple in which variables may
occur. Each conjunct in the body or the head is called an <em>atom</em>. In our
example, the body consists of atoms <code class="docutils literal notranslate"><span class="pre">[?x,</span> <span class="pre">:locatedIn,</span> <span class="pre">?y]</span></code> and <code class="docutils literal notranslate"><span class="pre">[?y,</span>
<span class="pre">:locatedIn,</span> <span class="pre">?z]</span></code>, whereas the head consists of the single atom <code class="docutils literal notranslate"><span class="pre">[?x,</span>
<span class="pre">:locatedIn,</span> <span class="pre">?z]</span></code>.</p>
<p>Each rule conveys the idea that, from certain combinations of triples in the
input RDF graph, we can logically deduce that some other triples must also be
part of the graph. In particular, variables in the rule range over all possible
nodes in the RDF graph (RDF literals, URIs, blank nodes); whenever these
variables are assigned values that make the rule body become subset of the
graph, then we see what the value of those variables is, propagate these values
to the head of the rule, and deduce that the resulting triples must also be a
part of the graph.</p>
<p>In our example, a particular rule application binds variable <code class="docutils literal notranslate"><span class="pre">?x</span></code> to
<code class="docutils literal notranslate"><span class="pre">:oxford</span></code>, variable <code class="docutils literal notranslate"><span class="pre">?y</span></code> to <code class="docutils literal notranslate"><span class="pre">:oxfordshire</span></code> and variable <code class="docutils literal notranslate"><span class="pre">?z</span></code> to
<code class="docutils literal notranslate"><span class="pre">:england</span></code>, which then implies that that triple <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span>
<span class="pre">:england</span></code> obtained by replacing <code class="docutils literal notranslate"><span class="pre">?x</span></code> with <code class="docutils literal notranslate"><span class="pre">:oxford</span></code> and <code class="docutils literal notranslate"><span class="pre">?z</span></code> with
<code class="docutils literal notranslate"><span class="pre">:england</span></code> in the head of the rule holds as a logical consequence. A
different rule application would bind <code class="docutils literal notranslate"><span class="pre">?x</span></code> to <code class="docutils literal notranslate"><span class="pre">:oxfordshire</span></code>, <code class="docutils literal notranslate"><span class="pre">?y</span></code> to
<code class="docutils literal notranslate"><span class="pre">:england</span></code>, and <code class="docutils literal notranslate"><span class="pre">?z</span></code> to <code class="docutils literal notranslate"><span class="pre">:uk</span></code>; as a result, the triple <code class="docutils literal notranslate"><span class="pre">:oxfordshire</span>
<span class="pre">:locatedIn</span> <span class="pre">:uk</span></code> can also be derived as a logical consequence.</p>
<p>An alternative way to understand the meaning of a single Datalog rule
application to an RDF graph is to look at it as the execution of an <code class="docutils literal notranslate"><span class="pre">INSERT</span></code>
statement in SPARQL, which adds a set of triples to the graph. In particular,
the statement</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>INSERT { ?x :locatedIn ?z } WHERE { ?x :locatedIn ?y. ?y :locatedIn ?z }
</pre></div>
</div>
<p>corresponding to our example rule leads to the insertion of triples</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :england .
:oxfordshire :locatedIn :uk .
</pre></div>
</div>
<p>There is, however, a fundamental difference that makes rules more powerful than
simple <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> statements in SPARQL, namely that rules are <strong>applied
recursively</strong> . Indeed, after we have derived that Oxford is located in
England, we can apply the rule again by matching <code class="docutils literal notranslate"><span class="pre">?x</span></code> to <code class="docutils literal notranslate"><span class="pre">:oxford</span></code>, <code class="docutils literal notranslate"><span class="pre">?y</span></code>
to <code class="docutils literal notranslate"><span class="pre">:england</span></code>, and <code class="docutils literal notranslate"><span class="pre">?z</span></code> to <code class="docutils literal notranslate"><span class="pre">:uk</span></code>, to derive <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:uk</span></code>—a
triple that is not obtained as a result of the <code class="docutils literal notranslate"><span class="pre">INSERT</span></code> statement above.</p>
<p>In this way, the logical consequences of a set of Datalog rules on an input
graph are captured by the recursive application of the rules until no new
information can be added to the graph. It is important to notice that the set
of new triples obtained is completely independent from the order in which rule
applications are performed as well as of the order in which different elements
of rule bodies are given. In particular, the following two rules are equivalent:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :locatedIn, ?z] :- [?x, :locatedIn, ?y], [?y, :locatedIn, ?z] .
[?x, :locatedIn, ?z] :- [?y, :locatedIn, ?z], [?x, :locatedIn, ?y] .
</pre></div>
</div>
</div>
<div class="section" id="extensions-of-datalog">
<h3><span class="section-number">10.1.2. </span>Extensions of Datalog<a class="headerlink" href="#extensions-of-datalog" title="Permalink to this headline">¶</a></h3>
<p>A wide range of extensions of Datalog have been proposed and studied in the
literature. In this subsection we describe the extensions of Datalog
implemented in RDFox as well as the restrictions on them that have been put in
place in order to ensure that the resulting language is semantically
well-defined. Later on in this section we will provide many more examples of
rules equipped with these extended features.</p>
<div class="section" id="negation-as-failure">
<h4><span class="section-number">10.1.2.1. </span>Negation-as-failure<a class="headerlink" href="#negation-as-failure" title="Permalink to this headline">¶</a></h4>
<p>Negation-as-failure allows us to make deductions based on information that is
<strong>not present</strong> in the graph. For instance, using negation-as-failure we can
write a rule saying that someone who works for a company but is not an employee
of the company is an external contractor.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :contractorFor, ?y] :- [?x, :worksFor, ?y], NOT [?x, :employeeOf, ?y] .
</pre></div>
</div>
<p>Here, <code class="docutils literal notranslate"><span class="pre">NOT</span></code> represents a negation of a body atom.</p>
<p>Let us consider the logical consequences of this rule when applied to the graph</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:mary :worksFor :acme .
:mary :employeeOf :acme .
:bob :worksFor :acme .
</pre></div>
</div>
<p>On the one hand, we have that <code class="docutils literal notranslate"><span class="pre">:mary</span></code> works for <code class="docutils literal notranslate"><span class="pre">:acme</span></code>, and hence we can
satisfy the first atom in the body by assigning <code class="docutils literal notranslate"><span class="pre">:mary</span></code> to <code class="docutils literal notranslate"><span class="pre">?x</span></code> and
<code class="docutils literal notranslate"><span class="pre">:acme</span></code> to <code class="docutils literal notranslate"><span class="pre">?y</span></code>; however, <code class="docutils literal notranslate"><span class="pre">:mary</span></code> is also an employee of <code class="docutils literal notranslate"><span class="pre">:acme</span></code>, and
hence the second condition is not satisfied, which means that we cannot derive
that <code class="docutils literal notranslate"><span class="pre">:mary</span></code> is a contractor. On the other hand, we also have that <code class="docutils literal notranslate"><span class="pre">:bob</span></code>
works for <code class="docutils literal notranslate"><span class="pre">:acme</span></code> and hence once again we can satisfy the first atom in the
body, this time by assigning <code class="docutils literal notranslate"><span class="pre">:bob</span></code> to <code class="docutils literal notranslate"><span class="pre">?x</span></code> and <code class="docutils literal notranslate"><span class="pre">:acme</span></code> to <code class="docutils literal notranslate"><span class="pre">?y</span></code>; but
now, we do not have a triple in the graph stating that <code class="docutils literal notranslate"><span class="pre">:bob</span></code> is an employee
of <code class="docutils literal notranslate"><span class="pre">:acme</span></code> and hence we can satisfy the second condition in the body and
derive the triple <code class="docutils literal notranslate"><span class="pre">:bob</span> <span class="pre">:contractorFor</span> <span class="pre">:acme</span></code>.</p>
<p>Indeed, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :contractorFor ?y }
</pre></div>
</div>
<p>yields the expected result</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:bob :acme .
</pre></div>
</div>
<p>Note that negation typically means “absence of information”; indeed, we do not
know for sure whether <code class="docutils literal notranslate"><span class="pre">:bob</span></code> is not an employee of <code class="docutils literal notranslate"><span class="pre">:acme</span></code>; we only know
that this information is not available in the graph (neither explicitly, nor as
a consequence of other rule applications).</p>
<p>Negation-as-failure is intrinsically <strong>nonmonotonic</strong>. In logic, this means
that new information may invalidate previous deductions. For instance, suppose
that <code class="docutils literal notranslate"><span class="pre">:bob</span></code> becomes an employee of <code class="docutils literal notranslate"><span class="pre">:acme</span></code> and, to reflect this, we add to
our data graph the triple <code class="docutils literal notranslate"><span class="pre">:bob</span> <span class="pre">:employeeOf</span> <span class="pre">:acme</span></code>. Then, we can no longer
infer that <code class="docutils literal notranslate"><span class="pre">:bob</span></code> is a contractor for <code class="docutils literal notranslate"><span class="pre">:acme</span></code> and the previous query will
now return an empty answer. In contrast, rules in plain Datalog are monotonic:
adding new triples to the graph cannot invalidate any consequences that we may
have previously drawn; for instance, by adding a triple <code class="docutils literal notranslate"><span class="pre">:england</span> <span class="pre">:locatedIn</span>
<span class="pre">:uk</span></code> to the example in our previous section, cannot invalidate a previous
inference such as <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:england</span></code>.</p>
<p>The syntax for expressing negation in RDFox rules can be found in
<a class="reference internal" href="#negation-syntax"><span class="std std-numref">Section 10.4.4</span></a>.</p>
</div>
<div class="section" id="aggregation">
<h4><span class="section-number">10.1.2.2. </span>Aggregation<a class="headerlink" href="#aggregation" title="Permalink to this headline">¶</a></h4>
<p>Aggregation is an important feature in query languages such as SQL or SPARQL.
It allows one to compute numeric values (such as minimums, maximums, sums,
counts or averages) on groups of solutions satisfying certain conditions (e.g.,
compute an average salary over the group of people working in the accounting
department).</p>
<p>In RDFox, it is possible to define relations based on the result of aggregate
calculations. For instance, consider the following data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:bob :worksFor :accounting .
:bob :salary &quot;50000&quot;^^xsd:integer .
:mary :worksFor :hr .
:mary :salary &quot;47000&quot;^^xsd:integer .
:jen :worksFor :accounting .
:jen :salary &quot;60000&quot;^^xsd:integer .
:accounting rdf:type :Department .
:hr rdf:type :Department .
</pre></div>
</div>
<p>We can write an RDFox rule that computes the average salary of each department,
and store the result in a newly introduced relation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?d, :deptAvgSalary, ?z] :-
    [?d, rdf:type, :Department],
    AGGREGATE(
        [?x, :worksFor, ?d],
        [?x, :salary, ?s]
        ON ?d
        BIND AVG(?s) AS ?z) .
</pre></div>
</div>
<p>Here, each group consists of a department with salaried employees, and for each
group the rule computes an average of the salaries involved. In particular,
suppose that we satisfy the first atom in the body by assigning value
<code class="docutils literal notranslate"><span class="pre">:accounting</span></code> to variable <code class="docutils literal notranslate"><span class="pre">?d</span></code>; then, we can satisfy the <em>aggregate atom</em>
by grouping all employees working for <code class="docutils literal notranslate"><span class="pre">:accounting</span></code> (i.e., <code class="docutils literal notranslate"><span class="pre">:bob</span></code> and
<code class="docutils literal notranslate"><span class="pre">:jen</span></code>), compute their average salary (55k) and assigning the resulting value
to variable <code class="docutils literal notranslate"><span class="pre">?z</span></code>; as a result, we can propagate the assignment of <code class="docutils literal notranslate"><span class="pre">?d</span></code> to
:accounting and of <code class="docutils literal notranslate"><span class="pre">?z</span></code> to 55,000 to the head and derive the triple</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:accounting :deptAvgSalary &quot;55000&quot;^^xsd:integer .
</pre></div>
</div>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?d ?s WHERE { ?d rdf:type :Department . ?d :deptAvgSalary ?s }
</pre></div>
</div>
<p>then returns the expected answers</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:accounting 55000.0 .
:hr 47000.0 .
</pre></div>
</div>
<p>Similarly to negation, aggregation is also a non-monotonic extension of
Datalog. In particular, if we were to add a new employee to the accounting
department with a salary of 52k, then we would need to withdraw our previous
inference that the average accounting salary equals 55k and adjust the average
accordingly.</p>
<p>The syntax for expressing aggregation in RDFox rules can be found in
<a class="reference internal" href="#aggregate-syntax"><span class="std std-numref">Section 10.4.5</span></a>.</p>
</div>
<div class="section" id="built-in-functions">
<h4><span class="section-number">10.1.2.3. </span>Built-in Functions<a class="headerlink" href="#built-in-functions" title="Permalink to this headline">¶</a></h4>
<p>Datalog can be extended with the use of functions in rule bodies. In
particular, one can use all functions described in <a class="reference internal" href="querying.html#built-in-functions"><span class="std std-numref">Section 9.2</span></a>,
with the exception of <code class="docutils literal notranslate"><span class="pre">NOW</span></code>, <code class="docutils literal notranslate"><span class="pre">RAND</span></code>, <code class="docutils literal notranslate"><span class="pre">UUID</span></code> and <code class="docutils literal notranslate"><span class="pre">STRUUID</span></code>, whose
behavior is non-deterministic.</p>
<p>We demonstrate the use of functions in rule bodies using the string
concatenation function <code class="docutils literal notranslate"><span class="pre">CONCAT</span></code>. The following rule computes the full name of
a person as the concatenation of their first name and their family name.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :fullName, ?n] :-
    [?x, :firstName, ?y],
    [?x, :lastName, ?z],
    BIND(CONCAT(?y, &quot; &quot;, ?z) AS ?n) .
</pre></div>
</div>
<p>Consider the application of this rule to the graph consisting of the following
triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:peter :firstName &quot;Peter&quot; .
:peter :lastName &quot;Griffin&quot; .
</pre></div>
</div>
<p>Then, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :fullName ?y }
</pre></div>
</div>
<p>would return the expected answer</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:peter &quot;Peter Griffin&quot; .
</pre></div>
</div>
<p>An important consequence of introducing built-in functions is that rules are
now capable of deriving triples mentioning new objects which did not occur in
the input data (such as “Peter Griffin” in the above example). This is not
possible using plain Datalog rules, where the application of a rule may
generate new triples, but these triples can only mention objects that were
present in the input data.</p>
<p>If users are not careful, they may write rules using built-in functions that
generate <em>infinitely many</em> new constants and hence there may be infinitely many
triples that logically follow from the rules and a (finite) input graph.</p>
<p>For instance, consider the following rule, which creates longer names from
shorter names.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?person, :hasName, ?longerName] :-
   [?person, :hasName, ?name],
   BIND(CONCAT(&quot;Longer name: &quot;, ?name) AS ?longerName) .
</pre></div>
</div>
<p>If we apply this rule to the input graph consisting of</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:peter :hasName &quot;Peter&quot;
</pre></div>
</div>
<p>we will derive an infinite “chain” of triples</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:peter :hasName &quot;Peter&quot;
:peter :hasName &quot;Longer name: Peter&quot;
:peter :hasName &quot;Longer name: Longer name: Peter&quot;
:peter :hasName &quot;Longer name: Longer name: Longer name: Peter&quot;
:peter :hasName &quot;Longer name: Longer name: Longer name: Longer name: Peter&quot;
...
</pre></div>
</div>
<p>In such cases, RDFox will run out of resources trying to compute infinitely
many new triples and will therefore not terminate. This is not due to a
limitation of RDFox as a system, but rather to the well-known fact that Datalog
becomes undecidable once extended with built-in functions that can introduce
arbitrarily many fresh objects.</p>
</div>
<div class="section" id="equality">
<span id="id2"></span><h4><span class="section-number">10.1.2.4. </span>Equality<a class="headerlink" href="#equality" title="Permalink to this headline">¶</a></h4>
<p>Equality is a special binary predicate that can be used to identify different
resources as representing the same real-world object. The equality predicate is
referred to as <code class="docutils literal notranslate"><span class="pre">owl:sameAs</span></code> in the standard W3C languages for the Semantic
Web. In addition to equality, W3C standard languages also define an
<em>inequality</em> predicate, which is referred to as <code class="docutils literal notranslate"><span class="pre">owl:differentFrom</span></code>.</p>
<p>By default, two resources with different names are not assumed to be actually
different. For instance, resources called <code class="docutils literal notranslate"><span class="pre">:marie_curie</span></code> and
<code class="docutils literal notranslate"><span class="pre">:marie_sklodowsca</span></code> may refer to the same object in the world (the renowned
scientist Marie Curie). In logic terms we typically say that by default we are
<em>not making the unique name assumption (UNA)</em>. In some applications, however,
it makes sense to make such assumption, and the effect of making the UNA is
that we will have implicit <code class="docutils literal notranslate"><span class="pre">owl:differentFrom</span></code> statements between all pairs
of resources mentioned in the data.</p>
<p>In RDFox we can enable the use of equality by initializing a store accordingly.
For instance, using the shell, we can initialize a data store with equality
reasoning turned on using the shell command</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>init seq equality noUNA
</pre></div>
</div>
<p>initializes a data store with equality reasoning and no UNA.</p>
<p>Extensions of Datalog with equality allow for the equality and inequality
predicates to appear in rules and data. For instance, consider the following
triples, where the second triple represents the fact that the URIs
<code class="docutils literal notranslate"><span class="pre">:marie_curie</span></code> and <code class="docutils literal notranslate"><span class="pre">:marie_sklodowsca</span></code> refer to the same person.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:marie_curie rdf:type :Scientist .
:marie_curie owl:sameAs :marie_sklodowsca .
</pre></div>
</div>
<p>A query asking RDFox for all scientists</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Scientist }
</pre></div>
</div>
<p>will return both <code class="docutils literal notranslate"><span class="pre">:marie_curie</span></code> and <code class="docutils literal notranslate"><span class="pre">:marie_sklodowsca</span></code> as a result.</p>
<p>Equality and inequality can also be used in rules. For instance, the following
rule establishes that a person can only have one biological mother</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?y, owl:sameAs, ?z] :- [?x, :hasMother, ?y], [?x, :hasMother, ?z] .
</pre></div>
</div>
<p>The application of this rule to the graph</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:irene_curie :hasMother :marie_curie .
:irene_curie :hasMother :marie_sklodowsca .
</pre></div>
</div>
<p>identifies <code class="docutils literal notranslate"><span class="pre">:marie_curie</span></code> and <code class="docutils literal notranslate"><span class="pre">:marie_sklodowsca</span></code> :as the same person.</p>
<p>The joint use of equality and inequality can lead to logical contradictions.
For instance, the application of the previous rule to a graph consisting of the
following triples would lead to a contradiction:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:irene_curie :hasMother :marie_curie .
:irene_curie :hasMother :eve_curie .
:marie_curie owl:differentFrom :eve_curie .
</pre></div>
</div>
<p>Indeed, the application of the rule derives <code class="docutils literal notranslate"><span class="pre">:marie_curie</span> <span class="pre">owl:sameAs</span>
<span class="pre">:eve_curie</span></code>, which is in contradiction with the data triple <code class="docutils literal notranslate"><span class="pre">:marie_curie</span>
<span class="pre">owl:differentFrom</span> <span class="pre">:eve_curie</span></code>. Such contradictions can be identified in RDFox
by querying for the instances of the special <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> predicate, which
is also borrowed from the W3C standard OWL. The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type owl:Nothing }
</pre></div>
</div>
<p>returns <code class="docutils literal notranslate"><span class="pre">:marie_curie</span></code> and <code class="docutils literal notranslate"><span class="pre">:eve_curie</span></code> as answers. This can be interpreted
by the user as: “resources :marie_curie and :irene_curie are involved in a
logical contradiction”.</p>
</div>
<div class="section" id="named-graphs-and-n-ary-relations">
<h4><span class="section-number">10.1.2.5. </span>Named Graphs and N-ary Relations<a class="headerlink" href="#named-graphs-and-n-ary-relations" title="Permalink to this headline">¶</a></h4>
<p>In all our previous examples, all atoms in rules are evaluated against the
<em>default RDF graph</em>. RDFox also supports named graphs, which can be populated
by importing an RDF dataset encoded as TriG or N-Quads, for example.</p>
<p>Named graphs can be used both in the body and the head of rules, and hence it
is possible to derive new triples as the result of rule application and add
them to graphs other than the default graph.</p>
<p>For instance, consider the following rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:monthlyPayment[?id, ?m] :Payroll :-
    [?id, rdf:type, :Employee],
    :yearlySalary[?id, ?s] :HR,
    BIND(?s / 12 AS ?m) .
</pre></div>
</div>
<p>This rule joins information from the default graph and the named graph called
<code class="docutils literal notranslate"><span class="pre">:HR</span></code>, and it inserts consequences into the named graph called <code class="docutils literal notranslate"><span class="pre">:Payroll</span></code>.
Specifically, the first body atom of the rule identifies IDs of employees in
the default RDF graph. The second body atom is a general atom: it is evaluated
in the named graph called <code class="docutils literal notranslate"><span class="pre">:HR</span></code>, and it matches triples that connect IDs with
their yearly salaries. The head of the rule contains a named graph atom that
refers to the named graph <code class="docutils literal notranslate"><span class="pre">:Payroll</span></code>, and it derives triples that associate
IDs of employees with their respective monthly payments. In particular, given
as data</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>GRAPH :HR { :a, :yearlySalary, &quot;55000&quot;^^xsd:integer }
:a rdf:type :Employee .
</pre></div>
</div>
<p>the rule will compute the monthly payment for employee <code class="docutils literal notranslate"><span class="pre">:a</span></code>. Then, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?s ?p ?o WHERE { GRAPH :Payroll { ?s ?p ?o } }
</pre></div>
</div>
<p>will correctly return the monthly payment for employee <code class="docutils literal notranslate"><span class="pre">:a</span></code></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:a :monthlyPayment 4583.333333333333333 .
</pre></div>
</div>
<p>RDFox can also directly represent external data as tuples of arbitrary arity
(not just triples) using the same syntax as named graphs. Atoms representing
such data, however, are only allowed to be used in the body of rules. Details
on how to access external data from RDFox are given in <a class="reference internal" href="data-sources.html#data-sources"><span class="std std-numref">Section 7</span></a>.</p>
</div>
</div>
</div>
<div class="section" id="materialization-based-reasoning">
<h2><span class="section-number">10.2. </span>Materialization-Based Reasoning<a class="headerlink" href="#materialization-based-reasoning" title="Permalink to this headline">¶</a></h2>
<p>The main computational problem solved by RDFox is that of answering a SPARQL
1.1 query with respect to an RDF graph and a set of rules.</p>
<p>To solve this problem, RDFox uses <em>materialization-based reasoning</em> to
precompute and store all triples that logically follow from the input graph and
rules in a query-independent way. Both the process of extending the input graph
with such newly derived triples and its final output are commonly called
<strong>materialization</strong>. After such preprocessing, queries can be answered directly
over the materialization, which is usually very efficient since the rules do
not need to be considered any further. Materializations can be large, but they
can usually be stored and handled on modern hardware as the available memory is
continually increasing.</p>
<p>The main challenge of this approach to query answering is that, whenever data
triples and/or rules are added and/or deleted, the “old” materialization must
be replaced with the “new” materialization that contains all triples that
follow from the updated input. In this setting, deletion of triples is
restricted to those that are explicit in the input graph and hence one does not
consider deletion of derived triples—a complex problem known in the literature
as belief revision or view update.</p>
<p>For instance, given as input the RDF graph</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :oxfordshire .
:oxfordshire :locatedIn :england .
:england :locatedIn :uk .
</pre></div>
</div>
<p>and the familiar rule</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :locatedIn, ?z] :- [?x, :locatedIn, ?y], [?y, :locatedIn, ?z] .
</pre></div>
</div>
<p>RDFox will compute the corresponding materialization, which consists of
triples</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :oxfordshire .
:oxford :locatedIn :england .
:oxford :locatedIn :uk .
:oxfordshire :locatedIn :england .
:oxfordshire :locatedIn :uk .
:england :locatedIn :uk .
</pre></div>
</div>
<p>RDFox will now handle each SPARQL 1.1 query issued against the input graph and
rule by simply evaluating the query directly over the materialization, thus
avoiding the expensive reasoning at query time.</p>
<p>An update could delete a triple explicitly given in the input graph such as the
triple :oxfordshire :locatedIn :england, in which case the new materialization
consists only of triples</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:oxford :locatedIn :oxfordshire .
:england :locatedIn :uk .
</pre></div>
</div>
<p>since the rule is no longer applicable after deletion. In contrast, deleting a
derived triple such as <code class="docutils literal notranslate"><span class="pre">:oxford</span> <span class="pre">:locatedIn</span> <span class="pre">:uk</span> <span class="pre">.</span></code> is not allowed since this
triple was not part of the original input.</p>
<p>RDFox implements sophisticated algorithms for both efficiently <em>computing</em>
materializations and <em>maintaining</em> them under addition/deletion updates that
may affect both the data and the rules. All these algorithms were developed
after years of research at Oxford and have been extensively documented in the
scientific literature.</p>
</div>
<div class="section" id="restrictions-on-rule-sets">
<h2><span class="section-number">10.3. </span>Restrictions on Rule Sets<a class="headerlink" href="#restrictions-on-rule-sets" title="Permalink to this headline">¶</a></h2>
<p>The rule language of RDFox imposes certain restrictions on the structure of
rule sets. These restrictions ensure that the materialization of a set of rules
and an RDF graph is well-defined and unique.</p>
<p>In particular, the semantics (i.e., the logical meaning) of rule sets involving
negation-as-failure and/or aggregation is not straightforward, and numerous
proposals exist in the scientific literature. There is, however, a general
consensus for rule sets in which the use of negation-as-failure and aggregation
are <strong>stratified</strong>. Informally, stratification conditions ensure that there are
no cyclic dependencies in the rule set involving negation or aggregation.</p>
<p>Several variants of stratification have been proposed, where some of them
capture a wider range of rule sets than others; they all, however, provide
similar guarantees. We next describe the stratification conditions adopted in
RDFox by means of examples. For this, let us consider the following rules
mentioning negation-as-failure:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :contractorFor, ?y] :-
   [?x, :worksFor, ?y],
   NOT [?x, :employeeOf, ?y] .

[?x, :employeeOf, :acme] :- [?x, :worksFor, :acme] .
</pre></div>
</div>
<p>The first rule says that people working for a company who are not employees of
that company act as contractors. The rule establishes two dependencies. The
first dependency tells us that the <em>presence</em> of a triple having <code class="docutils literal notranslate"><span class="pre">:worksFor</span></code>
in the middle position may contribute to triggering the derivation of a triple
having <code class="docutils literal notranslate"><span class="pre">:contractorFor</span></code> in the middle position. In turn, the second
dependency tells us that the <em>absence</em> of a triple having <code class="docutils literal notranslate"><span class="pre">:employeeOf</span></code> in
the middle position may also contribute to the derivation of a triple having
<code class="docutils literal notranslate"><span class="pre">:contractorFor</span></code> in the middle position.</p>
<p>The second rule tells us that everyone working for <code class="docutils literal notranslate"><span class="pre">:acme</span></code> is an employee of
<code class="docutils literal notranslate"><span class="pre">:acme</span></code>. This rule establishes one dependency, namely the presence of a
triple having <code class="docutils literal notranslate"><span class="pre">:worksFor</span></code> in the middle position and <code class="docutils literal notranslate"><span class="pre">:acme</span></code> in the
rightmost position may trigger the derivation of a triple having
<code class="docutils literal notranslate"><span class="pre">:employeeOf</span></code> in the middle position and <code class="docutils literal notranslate"><span class="pre">:acme</span></code> in the rightmost position.</p>
<p>We can keep track of such dependencies by means of a <em>dependency graph</em>. The
nodes of the graph are obtained by replacing variables in individual triple
patterns occurring in the rules with the special symbol <code class="docutils literal notranslate"><span class="pre">ANY</span></code>, which
intuitively indicates that the position of the triple where it occurs can adopt
any constant value, and leaving constants as they are. In particular, our
example rules yield a graph having the following five vertices v1—v5:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>v1:  ANY :contractorFor ANY
v2:  ANY :worksFor      ANY
v3:  ANY :employeeOf    ANY
v4:  ANY :worksFor      :acme
v5:  ANY :employeeOf    :acme
</pre></div>
</div>
<p>The (directed) edges of the graph lead from vertices corresponding to body
atoms to vertices corresponding to head atoms and can be either “regular” or
“special”. Special edges witness the presence of a dependency involving
aggregation or negation-as-failure; in our case, we will have a single special
edge (v3, v1). In turn, each dependency that is not via
negation-as-failure/aggregation generates a regular edge; in our case, we will
have regular edges (v2,v1) and (v4, v5). Finally, the graph will also contain
bidirectional regular edges between nodes that unify in the sense of
first-order logic: since <code class="docutils literal notranslate"><span class="pre">[?x,</span> <span class="pre">:employeeOf,</span> <span class="pre">?y]</span></code> and <code class="docutils literal notranslate"><span class="pre">[?x,</span> <span class="pre">:employeeOf,</span>
<span class="pre">:acme]</span></code> unify, we will have regular edges (v3,v5) and (v5, v3); similarly, we
will also have regular edges (v2,v4) and (v4,v2).</p>
<p>Our two example rules are stratified and hence are accepted by RDFox; this is
because there is no cycle in the dependency graph involving a special edge
(indeed, all cycles involve regular edges only).</p>
<p>Now suppose that the add the following rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :employeeOf, ?y] :-
   [?x, :worksFor, ?y],
   NOT [?x, :contractorFor, ?y] .
</pre></div>
</div>
<p>which says that people working for a company who are not contractors for the
company must be employees of the company. The addition of this rule does not
change the set of nodes in the dependency graph; however, it adds two more
edges: a regular edge (v2, v3) and a special edge (v1, v3). As a result, we now
have a cycle involving a special edge and the rule set is no longer stratified,
which means that the rule set will be rejected by RDFox as a result.</p>
<p>Due to stratification conditions, the use of the special equality relation
<code class="docutils literal notranslate"><span class="pre">owl:sameAs</span></code> in rules precludes the use of aggregation or
negation-as-failure. Consider the following rule set, where the second rule
tells us that a person cannot be an employee of two different companies:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :contractorFor, ?y] :-
   [?x, :worksFor, ?y],
   NOT [?x, :employeeOf, ?y] .

[?y, owl:sameAs, ?z] :-
   [?x, :employeeOf, ?y],
   [?x, :employeeOf, ?z] .
</pre></div>
</div>
<p>This rule set will be rejected by RDFox as the rule set mentions both <code class="docutils literal notranslate"><span class="pre">NOT</span></code>
and <code class="docutils literal notranslate"><span class="pre">owl:sameAs</span></code>. Informally, this is because equality can affect every
single relation, which precludes stratification in most cases.</p>
<p>In addition to stratification conditions, RDFox also requires certain
restrictions to the structure of rules which make sure that each rule can be
evaluated by binding the variables in the body of the rule to a data graph. To
see an example where things go wrong consider the rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :worksFor, ?y] :- [?y, rdf:type, :Department] .
</pre></div>
</div>
<p>The rule cannot be evaluated by first matching the body to the data graph and
then propagating the variable bindings to the head; indeed, rule body to an RDF
graph will always leave variable <code class="docutils literal notranslate"><span class="pre">?x</span></code> of the rule unbound and hence the
triple that must be added as a result of applying the rule to the data is
undefined. As a result, this rule will be rejected by RDFox.</p>
<p>Binding restrictions in RDFox are rather involved given that the underpinning
rule language is rich and there are many subtle corner cases. However, rules
accepted by the parser can always be unambiguously evaluated.</p>
</div>
<div class="section" id="the-rule-language-of-rdfox">
<span id="rdfox-datalog"></span><h2><span class="section-number">10.4. </span>The Rule Language of RDFox<a class="headerlink" href="#the-rule-language-of-rdfox" title="Permalink to this headline">¶</a></h2>
<p>This section formally describes the rule language of RDFox. As already
mentioned, the rule language supported by RDFox extends Datalog with stratified
negation, stratified aggregation, built-in functions, and more, so as to
provide additional data analysis capabilities.</p>
<p>A rule has the following form, where the formula to the left of the <code class="docutils literal notranslate"><span class="pre">:-</span></code>
operator is the rule head and the formula to the right is the rule <em>body</em>. Each
<code class="docutils literal notranslate"><span class="pre">Hi</span></code>, with <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">≤</span> <span class="pre">i</span> <span class="pre">≤</span> <span class="pre">j</span></code>, is a <strong>tuple table atom</strong>, and each <code class="docutils literal notranslate"><span class="pre">Li</span></code>, with
<code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">≤</span> <span class="pre">i</span> <span class="pre">≤</span> <span class="pre">k</span></code>, is a <strong>body formula</strong>. A body formula can be either an <strong>atom</strong>,
a <strong>negation</strong> or an <strong>aggregate</strong>, where an atom is a <strong>tuple table atom</strong>, a
<strong>filter atom</strong>, or a <strong>bind atom</strong>. Currently, the only tuple table atoms
allowed in rule’s heads are <strong>default graph atoms</strong> and <strong>named graph atoms</strong>.
A complete grammar of the rule language is given in <a class="reference internal" href="#rules-grammar"><span class="std std-numref">Section 10.4.6</span></a>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>H1 , …, Hj :- L1 , …, Lk .
</pre></div>
</div>
<p>Informally, a rule says that “if <code class="docutils literal notranslate"><span class="pre">L1</span></code>, …, and <code class="docutils literal notranslate"><span class="pre">Lk</span></code> all hold for some
bindings of the rule’s variables to RDF resources, then <code class="docutils literal notranslate"><span class="pre">H1</span></code>, …, and <code class="docutils literal notranslate"><span class="pre">Hj</span></code>
also hold for the same bindings.” Rule evaluation is the process of finding all
variable bindings for which the rule body holds. For every such variable
binding, the triples obtained from the rule head by replacing the variables
according to their binding are added to the current store. A rule can be
evaluated, only if each variable in its head can be bound by its body. The
ordering of the head atoms and/or the body formulas does not affect the meaning
of a rule.</p>
<p>Successful variable bindings are computed by consecutively evaluating the body
formulas in the rule. The evaluation of a body formula may succeed or fail for
the current variable bindings. If successfully evaluated, some body formulas
can bind previously unbound variables. These include tuple table atoms, bind
atoms, and aggregates. Some body formulas may require that certain variables
are bound before they can be evaluated. These include bind atoms, filter atoms,
and general atoms backed by certain built-in tables and external sources.
Finally, body formulas may have local variables that are not visible by the
rest of the rule. These include the negation and the aggregate body formulas.
Any mentioning of a local variable in a different context is treated as a
different variable.</p>
<p>In the following sections we are going to describe the different constituents
of a rule in more detail. The word <strong>term</strong> denotes either an RDF resource or a
<a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">SPARQL variable</a>.</p>
<div class="section" id="tuple-table-atom">
<span id="atom"></span><h3><span class="section-number">10.4.1. </span>Tuple Table Atom<a class="headerlink" href="#tuple-table-atom" title="Permalink to this headline">¶</a></h3>
<p>A tuple table atom can be either a <strong>default graph atom</strong>, a <strong>named graph
atom</strong> or a <strong>general atom</strong>. Default and named graph atoms are used to refer
to RDF data in the current store, while general atoms can refer to built-in
tuple tables or data source tuple tables. All three types of tuple table atoms
provide bindings for the variables that occur in them.</p>
<div class="section" id="default-graph-atom">
<span id="id3"></span><h4><span class="section-number">10.4.1.1. </span>Default Graph Atom<a class="headerlink" href="#default-graph-atom" title="Permalink to this headline">¶</a></h4>
<p>A default graph atom has the form <code class="docutils literal notranslate"><span class="pre">[t1,</span> <span class="pre">t2,</span> <span class="pre">t3]</span></code>, where <code class="docutils literal notranslate"><span class="pre">ti</span></code> are terms. If
<code class="docutils literal notranslate"><span class="pre">t2</span></code> is an IRI, then the atom <code class="docutils literal notranslate"><span class="pre">[t1,</span> <span class="pre">t2,</span> <span class="pre">t3]</span></code> can be written alternatively
as <code class="docutils literal notranslate"><span class="pre">t2[t1,</span> <span class="pre">t3]</span></code>. Furthermore, when <code class="docutils literal notranslate"><span class="pre">t2</span></code> is the special IRI <code class="docutils literal notranslate"><span class="pre">rdf:type</span></code> and
<code class="docutils literal notranslate"><span class="pre">t3</span></code> is also an IRI, atom <code class="docutils literal notranslate"><span class="pre">[t1,</span> <span class="pre">t2,</span> <span class="pre">t3]</span></code> can be written alternatively as
<code class="docutils literal notranslate"><span class="pre">t3[t1]</span></code>. Default graph atoms are evaluated against the triples in the
default graph of an RDF dataset, with <code class="docutils literal notranslate"><span class="pre">t1</span></code>, <code class="docutils literal notranslate"><span class="pre">t2</span></code> and <code class="docutils literal notranslate"><span class="pre">t3</span></code> matching the
subject, predicate and object of each triple.</p>
<div class="example docutils container">
<p><strong>Example</strong> <em>A simple rule with default graph atoms only</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Person] :- [?x, :teacherOf, ?y] .
</pre></div>
</div>
<p>As we discussed earlier, this is equivalent to:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Person[?x] :- :teacherOf[?x, ?y] .
</pre></div>
</div>
<p>The above rule asserts that for every triple <code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">:teacherOf,</span> <span class="pre">s)</span></code> in
the default graph, a triple <code class="docutils literal notranslate"><span class="pre">(t,</span> <span class="pre">rdf:type,</span> <span class="pre">:Person)</span></code> has to be added to
the default graph as well.</p>
</div>
</div>
<div class="section" id="named-graph-atom">
<span id="id4"></span><h4><span class="section-number">10.4.1.2. </span>Named Graph Atom<a class="headerlink" href="#named-graph-atom" title="Permalink to this headline">¶</a></h4>
<p>A named graph atom is a default graph atom followed by an RDF term representing
the named graph.</p>
<div class="example docutils container">
<p><strong>Example</strong> <em>A rule referring to a named graph</em> <code class="docutils literal notranslate"><span class="pre">:Personnel</span></code> <em>in an RDF
dataset.</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Person[?person] :Personnel,
:Address[?address] :Personnel :-
    :hasAddress[?person, ?address] :Personnel.
</pre></div>
</div>
<p>The above rule asserts that for every RDF triple <code class="docutils literal notranslate"><span class="pre">(person,</span> <span class="pre">:hasAddress,</span>
<span class="pre">address)</span></code> in the named graph <code class="docutils literal notranslate"><span class="pre">:Personnel</span></code>, the two RDF triples
<code class="docutils literal notranslate"><span class="pre">(person,</span> <span class="pre">rdf:type,</span> <span class="pre">:Person)</span></code> and <code class="docutils literal notranslate"><span class="pre">(address,</span> <span class="pre">rdf:type,</span> <span class="pre">Address)</span></code> have
to be added to the named graph <code class="docutils literal notranslate"><span class="pre">:Personnel</span></code>.</p>
</div>
</div>
<div class="section" id="general-atom">
<span id="id5"></span><h4><span class="section-number">10.4.1.3. </span>General Atom<a class="headerlink" href="#general-atom" title="Permalink to this headline">¶</a></h4>
<p>A general atom has the form <code class="docutils literal notranslate"><span class="pre">A(t1,</span> <span class="pre">…,</span> <span class="pre">tn)</span></code>, where <code class="docutils literal notranslate"><span class="pre">n</span> <span class="pre">≥</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">A</span></code> is a tuple
table name in the current store, and <code class="docutils literal notranslate"><span class="pre">t1,</span> <span class="pre">…,</span> <span class="pre">tn</span></code> are terms. General tuple
table atoms can refer to in-memory tuple tables (such as the ones used to store
triples in the default and the named graphs), as well as built-in tuple tables
and data source tuple tables.</p>
<div class="example docutils container">
<p><strong>Example</strong> <em>A rule with a general atom</em></p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasFirstName[?person, ?firstName],
:hasLastName[?person, ?lastName],
:hasAddress[?person, ?address] :-
    Person(?person, ?firstName, ?lastName, ?address) .
</pre></div>
</div>
<p>The rule asserts that, for every tuple <code class="docutils literal notranslate"><span class="pre">(person,</span> <span class="pre">firstName,</span> <span class="pre">lastName,</span>
<span class="pre">address)</span></code> in the table <code class="docutils literal notranslate"><span class="pre">Person</span></code>, the following RDF triples should be
added to the default graph of the current RDF dataset.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>(person, :hasFirstName, firstName)
(person, :hasLastName, lastName)
(person, :hasAddress, address)
</pre></div>
</div>
</div></blockquote>
</div>
</div>
</div>
<div class="section" id="bind-atom">
<h3><span class="section-number">10.4.2. </span>Bind Atom<a class="headerlink" href="#bind-atom" title="Permalink to this headline">¶</a></h3>
<p>A bind atom has the form <code class="docutils literal notranslate"><span class="pre">BIND(exp</span> <span class="pre">AS</span> <span class="pre">v)</span></code>, where <code class="docutils literal notranslate"><span class="pre">exp</span></code> is an <strong>expression</strong>
and <code class="docutils literal notranslate"><span class="pre">v</span></code> is a variable not occurring in <code class="docutils literal notranslate"><span class="pre">exp</span></code>. Expressions are constructed
from variables, RDF resources, and the operators and functions supported by
RDFox (see <a class="reference internal" href="querying.html#querying"><span class="std std-numref">Section 9</span></a>) with the exception of functions whose values are
not determined by values of their arguments (e.g. <code class="docutils literal notranslate"><span class="pre">NOW()</span></code> and <code class="docutils literal notranslate"><span class="pre">RAND()</span></code>). A
bind atom can be evaluated after all variables in its expression have been
bound by other body formulas. The value of the expression is then assigned to
<code class="docutils literal notranslate"><span class="pre">v</span></code>, if <code class="docutils literal notranslate"><span class="pre">v</span></code> has not been previously bound. Otherwise, the value of the
expression is compared with that of the variable, and the evaluation of the
bind atom succeeds, if the two values agree. A bind atom provides a binding for
its target variable <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike SPARQL 1.1, a bind atom in a rule can be evaluated only if all
variables in its expression are bound by other body formulas in the rule.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Using bind atom</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:cTemperature[?x, ?z] :- :fTemperature[?x, ?y], BIND ((?y - 32) / 1.8 AS ?z) .
</pre></div>
</div>
<p>The bind atom in the above rule converts Fahrenheit degrees to Celsius
degrees. Note that the tuple table atom <code class="docutils literal notranslate"><span class="pre">:fTemperature[?x,</span> <span class="pre">?y]</span></code> will be
evaluated before the bind atom, since that is the only way <code class="docutils literal notranslate"><span class="pre">?y</span></code> can be
bound. This is true even if the above rule is rewritten as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:cTemperature[?x, ?z] :- BIND ((?y - 32) / 1.8 AS ?z), :fTemperature[?x, ?y] .
</pre></div>
</div>
</div>
</div>
<div class="section" id="filter-atom">
<h3><span class="section-number">10.4.3. </span>Filter Atom<a class="headerlink" href="#filter-atom" title="Permalink to this headline">¶</a></h3>
<p>A filter atom has the form <code class="docutils literal notranslate"><span class="pre">FILTER(exp)</span></code>, where <code class="docutils literal notranslate"><span class="pre">exp</span></code> is an expression. A
filter atom can be evaluated only after all variables in its expression have
been previously bound. The evaluation of a filter atom succeeds if the <code class="docutils literal notranslate"><span class="pre">exp</span></code>
evaluates to <code class="docutils literal notranslate"><span class="pre">true</span></code> for the current variable bindings. Filter atoms provide
no variable bindings.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Unlike SPARQL 1.1, a filter atom in a rule can be evaluated only if all
variables in its expression are bound by other body formulas in the rule.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Using filter atoms</em></p>
<blockquote>
<div><div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:PositiveNumber[?x] :- :Number[?x], FILTER(?x &gt; 0) .
</pre></div>
</div>
<p>The rule says that a number is positive if it is larger than zero. Since
the order of the body formulas does not matter, the rule can be
equivalently written as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:PositiveNumber[?x] :- FILTER(?x &gt; 0), :Number[?x] .
</pre></div>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="negation">
<span id="negation-syntax"></span><h3><span class="section-number">10.4.4. </span>Negation<a class="headerlink" href="#negation" title="Permalink to this headline">¶</a></h3>
<p>A negation has one of the following forms, where <code class="docutils literal notranslate"><span class="pre">k,j</span> <span class="pre">≥</span> <span class="pre">1</span></code>, <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> are
atoms, and <code class="docutils literal notranslate"><span class="pre">?V1,</span> <span class="pre">…,</span> <span class="pre">?Vj</span></code> are variables local to the body formula. A negation
formula can be evaluated only after all its nonlocal variables have been bound.
The evaluation of a negation succeeds for the given variable bindings, if there
are no bindings for <code class="docutils literal notranslate"><span class="pre">?V1,</span> <span class="pre">…,</span> <span class="pre">?Vj</span></code> to resources that make <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> true.
Each variable in <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> has to be ether bound by another body formula in
the rule or has to appear in the variable list after <code class="docutils literal notranslate"><span class="pre">EXIST</span></code>/<code class="docutils literal notranslate"><span class="pre">EXISTS</span></code>.
Negation body formulas provide no variable bindings.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>NOT B1
NOT(B1, …, Bk)
NOT EXIST ?V1, …, ?Vj IN B1
NOT EXIST ?V1, …, ?Vj IN (B1, …, Bk)
NOT EXISTS ?V1, …, ?Vj IN B1
NOT EXISTS ?V1, …, ?Vj IN (B1, …, Bk)
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Negation introduces a new variable scope; that is, all variables <code class="docutils literal notranslate"><span class="pre">?V1,</span> <span class="pre">…,</span>
<span class="pre">?Vj</span></code> listed after <code class="docutils literal notranslate"><span class="pre">EXIST/EXISTS</span></code> are local to the scope of the negation
body formula, and any occurrence of such variables elsewhere in the rule
will be treated by RDFox as a different variable (an example is provided
below).</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RDFox will reject rules that use negation in all <code class="docutils literal notranslate"><span class="pre">equality</span></code> modes other
than <code class="docutils literal notranslate"><span class="pre">off</span></code> (see <a class="reference internal" href="#equality"><span class="std std-ref">Equality</span></a>).</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Using negation with NOT</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasOptionalComponent[?x, ?y] :-
    :hasComponent[?x, ?y],
    NOT :hasMandatoryComponent[?x, ?y] .
</pre></div>
</div>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Using negation with NOT EXISTS</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:BasicComponent[?x] :-
   :Component[?x],
   NOT EXISTS ?y IN (
       :Component[?y],
       :hasComponent[?x, ?y]
   ) .
</pre></div>
</div>
<p>The rule defines as basic all components that have no subcomponents.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Variable used in different scopes</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:TopComponent[?x] :-
    :hasComponent[?x, ?y],
    NOT EXISTS ?y IN (
        :hasComponent[?y, ?x]
    ) .
</pre></div>
</div>
<p>We can see that variable <code class="docutils literal notranslate"><span class="pre">?y</span></code> is used both inside and outside the scope
of <code class="docutils literal notranslate"><span class="pre">EXISTS</span></code>. As already mentioned, such occurrences will be treated by
RDFox as referring to different variables; in particular, we can obtain an
equivalent rule by replacing all occurrences of <code class="docutils literal notranslate"><span class="pre">?y</span></code> outside the scope of
<code class="docutils literal notranslate"><span class="pre">EXISTS</span></code> with a new variable <code class="docutils literal notranslate"><span class="pre">?z</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:TopComponent[?x] :-
    :hasComponent[?x, ?z],
    NOT EXISTS ?y IN (
        :hasComponent[?y, ?x]
    ) .
</pre></div>
</div>
</div>
</div>
<div class="section" id="aggregate">
<span id="aggregate-syntax"></span><h3><span class="section-number">10.4.5. </span>Aggregate<a class="headerlink" href="#aggregate" title="Permalink to this headline">¶</a></h3>
<p>Aggregates are used to compute expressions over sets of values using
<strong>aggregate functions</strong> like <code class="docutils literal notranslate"><span class="pre">COUNT</span></code>, <code class="docutils literal notranslate"><span class="pre">MIN</span></code>, and <code class="docutils literal notranslate"><span class="pre">SUM</span></code>.
Reasoning supports all aggregate functions described in <a class="reference internal" href="querying.html#aggregate-functions"><span class="std std-numref">Section 9.3</span></a>
with the exception of the non-deterministic functions <code class="docutils literal notranslate"><span class="pre">SAMPLE</span></code>, <code class="docutils literal notranslate"><span class="pre">SAMPLE_ARGMIN</span></code>,
<code class="docutils literal notranslate"><span class="pre">SAMPLE_ARGMAX</span></code>, and <code class="docutils literal notranslate"><span class="pre">GROUP_CONCAT</span></code>. An aggregate has the following form</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>AGGREGATE(B1, …, Bk ON ?X1 … ?Xj BIND f1(exp1) AS ?V1 … BIND fn(expn) AS ?Vn)
</pre></div>
</div>
<p>where k ≥ 1, j ≥ 0, n ≥ 0, and</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> are atoms,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">?X1,</span> <span class="pre">…,</span> <span class="pre">?Xj</span></code> are <strong>group variables</strong> that appear in <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">exp1,</span> <span class="pre">…,</span> <span class="pre">expn</span></code> are (list of) expressions over the variables in
<code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code>, optionally prefixed by the keyword <code class="docutils literal notranslate"><span class="pre">DISTINCT</span></code>,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">f1,</span> <span class="pre">…,</span> <span class="pre">fn</span></code> are aggregate functions, and</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">?V1,</span> <span class="pre">…,</span> <span class="pre">?Vn</span></code> are variables that do not appear in <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code>.</p></li>
</ul>
<p>The evaluation of an aggregate will find all variable bindings that make <code class="docutils literal notranslate"><span class="pre">B1,</span>
<span class="pre">…,</span> <span class="pre">Bk</span></code> true. These bindings are grouped by the values of the group variables,
and the aggregate bind expressions are evaluated for each group. Non-group
variables that appear in <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> are local to the aggregate. Aggregates
provide bindings for the group variables (i.e. <code class="docutils literal notranslate"><span class="pre">?X1,</span> <span class="pre">…,</span> <span class="pre">?Xj</span></code>) and the target
variables of their aggregate binds (i.e. <code class="docutils literal notranslate"><span class="pre">?V1,</span> <span class="pre">…,</span> <span class="pre">?Vn</span></code>).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>An aggregate atom introduces a new variable scope. In particular, all
variables in an aggregate occurring in atoms <code class="docutils literal notranslate"><span class="pre">B1,</span> <span class="pre">…,</span> <span class="pre">Bk</span></code> but which are
not mentioned group variables are local to the aggregate; any occurrence of
such local variables outside the atom will be treated by RDFox as a
different variable.</p>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>RDFox will reject rules that use aggregation in all <code class="docutils literal notranslate"><span class="pre">equality</span></code> modes
other than <code class="docutils literal notranslate"><span class="pre">off</span></code> (see <a class="reference internal" href="#equality"><span class="std std-ref">Equality</span></a>).</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Compute the minimum and maximum ages for the members in a family</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:minAge[?family, ?minAge],
:maxAge[?family, ?maxAge] :-
    :Family[?family],
    AGGREGATE (
          :hasMember[?family, ?member],
          :hasAge[?member, ?age]
          ON ?family
          BIND MIN(?age) AS ?minAge
          BIND MAX(?age) AS ?maxAge
    ) .
</pre></div>
</div>
<p>The above rule computes the minimum and maximum age of the members of each
family. Variables <code class="docutils literal notranslate"><span class="pre">?family</span></code>, <code class="docutils literal notranslate"><span class="pre">?minAge</span></code> and <code class="docutils literal notranslate"><span class="pre">?maxAge</span></code> are global to
the rule, whereas the variables <code class="docutils literal notranslate"><span class="pre">?member</span></code> and <code class="docutils literal notranslate"><span class="pre">?age</span></code> are local to the
aggregate, as they are variables that occur in the aggregate atoms and are
not grouped.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Compute the adult-to-child ratio in each family</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasAdultToChildRatio[?family, ?ratio] :-
    :Family[?family],
    AGGREGATE (
        :hasMember[?family, ?member],
        :hasAge[?member, ?age],
        FILTER(?age &gt;= 18)
        ON ?family
        BIND COUNT(?member) AS ?numberOfAdults
    ),
    AGGREGATE (
        :hasMember[?family, ?member],
        :hasAge[?member, ?age],
        FILTER(?age &lt; 18)
        ON ?family
        BIND COUNT(?member) AS ?numberOfChildren
    ),
    BIND(?numberOfAdults / ?numberOfChildren AS ?ratio) .
</pre></div>
</div>
<p>The above rule computes the adult-to-child ratio in each family. Note that
the variable <code class="docutils literal notranslate"><span class="pre">?member</span></code> occurs locally in each of the aggregate atoms,
since it is not a group variable. As a result, the two occurrences can be
thought of as referring to different variables, and the above rule would be
equivalent to a rule where the two occurrences of <code class="docutils literal notranslate"><span class="pre">?member</span></code> are replaced
by <code class="docutils literal notranslate"><span class="pre">?member1</span></code> and <code class="docutils literal notranslate"><span class="pre">?member2</span></code>, respectively.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Define close families</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasCloseFamily[?family1, ?family2] :-
    AGGREGATE (
        :Family[?family1],
        :hasMember[?family1, ?member1],
        :Family[?family2],
        :hasMember[?family2, ?member2],
        :hasFriend[?member1, ?member2]
        ON ?family1 ?family2
        BIND COUNT(*) AS ?numberOfFriendships
    ),
    FILTER (?numberOfFriendships &gt; 3) .
</pre></div>
</div>
<p>The above rule defines as close those pairs of families that share more
than three friendships between their members.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Using the keyword DISTINCT</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasFamilyFriendsCount[?x, ?cnt] :-
    :Family[?x],
    AGGREGATE(
        :hasMember[?x, ?y],
        :hasFriend[?y, ?z]
        ON ?x
        BIND COUNT(DISTINCT ?z) AS ?cnt) .
</pre></div>
</div>
<p>This rule counts the number of distinct family friends; a person is
considered a family friend, if they are a friend of a family member.</p>
</div>
<div class="example docutils container">
<p><strong>Example</strong> <em>Compute statistics about maximum age</em></p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:hasMaxAge[:census, ?maxAge],
:hasMaxAgeFrequency[:census, ?maxAgeFrequency],
:hasMaxAgeFirstPerson[:census, ?firstWithMaxAge] :-
    AGGREGATE (
        :Person[?person],
        :hasAge[?person, ?age],
        :hasName[?person, ?name]
        BIND MAX(?age) AS ?maxAge
        BIND COUNT_MAX(?age) AS ?maxAgeFrequency
        BIND MIN_ARGMAX(?name, ?age) AS ?firstWithMaxAge
    ).
</pre></div>
</div>
<p>The above rule computes the maximum age of all people, how many people have
that age and the first person alphabetically that has that age.</p>
</div>
</div>
<div class="section" id="grammar">
<span id="rules-grammar"></span><h3><span class="section-number">10.4.6. </span>Grammar<a class="headerlink" href="#grammar" title="Permalink to this headline">¶</a></h3>
<p>This section presents the RDFox rule language grammar.</p>
<table class="colwidths-given docutils align-default" id="id10">
<caption><span class="caption-text">RDFox Rules Grammar</span><a class="headerlink" href="#id10" title="Permalink to this table">¶</a></caption>
<colgroup>
<col style="width: 19%" />
<col style="width: 4%" />
<col style="width: 77%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><strong>Ruleset</strong></p></td>
<td><p>:=</p></td>
<td><p>(&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rPrefixDecl">PrefixDecl</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>Rule</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>Fact</strong> &nbsp;&nbsp;&nbsp;&nbsp;) <sup>*</sup></p></td>
</tr>
<tr class="row-even"><td><p><strong>Rule</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>RuleHead</strong> &nbsp;&nbsp;&nbsp;&nbsp;' :- '&nbsp;&nbsp;&nbsp;&nbsp; <strong>RuleBody</strong> &nbsp;&nbsp;&nbsp;&nbsp;' . '</p></td>
</tr>
<tr class="row-odd"><td><p><strong>Fact</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>TupleTableAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;' . '</p></td>
</tr>
<tr class="row-even"><td><p><strong>RuleHead</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>TupleTableAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>TupleTableAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup></p></td>
</tr>
<tr class="row-odd"><td><p><strong>RuleBody</strong></p></td>
<td><p>:=</p></td>
<td><p>(&nbsp;&nbsp;&nbsp;&nbsp; <strong>BodyFormula</strong> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>BodyFormula</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup> &nbsp;&nbsp;&nbsp;&nbsp;) ?</p></td>
</tr>
<tr class="row-even"><td><p><strong>BodyFormula</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>Atom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>Negation</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>Aggregate</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Atom</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>TupleTableAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>FilterAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>BindAtom</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>TupleTableAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>DefaultGraphAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>NamedGraphAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>GeneralAtom</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>DefaultGraphAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>DefaultGraphTripleAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>DefaultGraphPropertyAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>DefaultGraphClassAtom</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>DefaultGraphTripleAtom</strong></p></td>
<td><p>:=</p></td>
<td><p>' [ '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' ] '</p></td>
</tr>
<tr class="row-odd"><td><p><strong>DefaultGraphPropertyAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><a class="reference external" href="https://www.w3.org/TR/sparql11-query/#riri">iri</a> &nbsp;&nbsp;&nbsp;&nbsp;' [ '&nbsp;&nbsp;&nbsp;&nbsp;  <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' ] '</p></td>
</tr>
<tr class="row-even"><td><p><strong>DefaultGraphClassAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><a class="reference external" href="https://www.w3.org/TR/sparql11-query/#riri">iri</a> &nbsp;&nbsp;&nbsp;&nbsp;' [ '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp;' ] '&nbsp;&nbsp;&nbsp;&nbsp;</p></td>
</tr>
<tr class="row-odd"><td><p><strong>NamedGraphAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>DefaultGraphAtom</strong> &nbsp;&nbsp;&nbsp;&nbsp; <strong>Graph</strong></p></td>
</tr>
<tr class="row-even"><td><p><strong>Graph</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>Term</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>GeneralAtom</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>TupleTableName</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Term</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'</p></td>
</tr>
<tr class="row-even"><td><p><strong>TupleTableName</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>ID</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>QuotedString</strong></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Term</strong></p></td>
<td><p>:=</p></td>
<td><p><a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#riri">iri</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rBlankNode">bnode</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rRDFLiteral">RDFLiteral</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rNumericLiteral">NumericLiteral</a> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rBooleanLiteral">BooleanLiteral</a></p></td>
</tr>
<tr class="row-even"><td><p><strong>FilterAtom</strong></p></td>
<td><p>:=</p></td>
<td><p>' FILTER '&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'</p></td>
</tr>
<tr class="row-odd"><td><p><strong>BindAtom</strong></p></td>
<td><p>:=</p></td>
<td><p>' BIND '&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp;' AS '&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'</p></td>
</tr>
<tr class="row-even"><td><p><strong>Expression</strong></p></td>
<td><p>:=</p></td>
<td><p><em>any valid</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rExpression">SPARQL expression</a> <em>with no</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rExistsFunc">EXISTS</a> <em>and</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rNotExistsFunc">NOT EXISTS</a> <em>subexpressions, and with built-in functions restricted to RDFox built-in functions, but excluding</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#func-now">NOW</a> <em>,</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#idp2130040">RAND</a> <em>,</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#func-uuid">UUID</a> <em>,</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#func-struuid">STRUUID</a> <em>and</em> <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rAggregate">aggregate</a> <em>functions</em></p></td>
</tr>
<tr class="row-odd"><td><p><strong>Negation</strong></p></td>
<td><p>:=</p></td>
<td><p>' NOT '&nbsp;&nbsp;&nbsp;&nbsp; <strong>ExistsClause</strong> ? &nbsp;&nbsp;&nbsp;&nbsp; ( &nbsp;&nbsp;&nbsp;&nbsp; <strong>Atom</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; <strong>AtomList</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp;)</p></td>
</tr>
<tr class="row-even"><td><p><strong>AtomList</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>Atom</strong> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Atom</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup></p></td>
</tr>
<tr class="row-odd"><td><p><strong>ExistsClause</strong></p></td>
<td><p>:=</p></td>
<td><p>(&nbsp;&nbsp;&nbsp;&nbsp;' EXIST ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' EXISTS '&nbsp;&nbsp;&nbsp;&nbsp;) &nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup> &nbsp;&nbsp;&nbsp;&nbsp; ' IN '&nbsp;&nbsp;&nbsp;&nbsp;</p></td>
</tr>
<tr class="row-even"><td><p><strong>Aggregate</strong></p></td>
<td><p>:=</p></td>
<td><p>' AGGREGATE '&nbsp;&nbsp;&nbsp;&nbsp; '&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; <strong>AtomList</strong> &nbsp;&nbsp;&nbsp;&nbsp; <strong>OnClause</strong> ? &nbsp;&nbsp;&nbsp;&nbsp; <strong>AggregateBind</strong> <sup>*</sup> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'</p></td>
</tr>
<tr class="row-odd"><td><p><strong>OnClause</strong></p></td>
<td><p>:=</p></td>
<td><p>' ON '&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a> <sup>+</sup></p></td>
</tr>
<tr class="row-even"><td><p><strong>AggregateBind</strong></p></td>
<td><p>:=</p></td>
<td><p>' BIND '&nbsp;&nbsp;&nbsp;&nbsp; ( &nbsp;&nbsp;&nbsp;&nbsp; <strong>AggregateExpression1</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>AggregateExpression2</strong> &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>CountExpression</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) &nbsp;&nbsp;&nbsp;&nbsp;' AS '&nbsp;&nbsp;&nbsp;&nbsp; <a class="reference external" href="https://www.w3.org/TR/sparql11-query/#rVar">var</a></p></td>
</tr>
<tr class="row-odd"><td><p><strong>AggregateExpression1</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>AggregateFunction1</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' DISTINCT '&nbsp;&nbsp;&nbsp;&nbsp; ) ? &nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp;</p></td>
</tr>
<tr class="row-even"><td><p><strong>AggregateExpression2</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>AggregateFunction2</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' DISTINCT '&nbsp;&nbsp;&nbsp;&nbsp; ) ? &nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong>  &nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp;</p></td>
</tr>
<tr class="row-odd"><td><p><strong>AggregateFunction1</strong></p></td>
<td><p>:=</p></td>
<td><p>(&nbsp;&nbsp;&nbsp;&nbsp;' SUM ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MUL ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' AVG ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MIN ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' COUNT_MIN ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MAX ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' COUNT_MAX '&nbsp;&nbsp;&nbsp;&nbsp;)</p></td>
</tr>
<tr class="row-even"><td><p><strong>AggregateFunction2</strong></p></td>
<td><p>:=</p></td>
<td><p>(&nbsp;&nbsp;&nbsp;&nbsp;' MIN_ARGMIN ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MAX_ARGMIN ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MIN_ARGMAX ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; ' MAX_ARGMAX '&nbsp;&nbsp;&nbsp;&nbsp;)</p></td>
</tr>
<tr class="row-odd"><td><p><strong>CountExpression</strong></p></td>
<td><p>:=</p></td>
<td><p>' COUNT ' &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;(&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp; ( &nbsp;&nbsp;&nbsp;&nbsp;' DISTINCT '&nbsp;&nbsp;&nbsp;&nbsp; ) ? &nbsp;&nbsp;&nbsp;&nbsp; ( &nbsp;&nbsp;&nbsp;&nbsp;' * ' &nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp; <strong>ExpressionList</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) ? &nbsp;&nbsp;&nbsp;&nbsp;'&nbsp;)&nbsp;'&nbsp;&nbsp;&nbsp;&nbsp;</p></td>
</tr>
<tr class="row-even"><td><p><strong>ExpressionList</strong></p></td>
<td><p>:=</p></td>
<td><p><strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp; (&nbsp;&nbsp;&nbsp;&nbsp;' , '&nbsp;&nbsp;&nbsp;&nbsp; <strong>Expression</strong> &nbsp;&nbsp;&nbsp;&nbsp; ) <sup>*</sup></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="common-uses-of-rules-in-practice">
<h2><span class="section-number">10.5. </span>Common Uses of Rules in Practice<a class="headerlink" href="#common-uses-of-rules-in-practice" title="Permalink to this headline">¶</a></h2>
<p>This section describes common uses of rules and reasoning in practical
applications. This section will be especially useful for practitioners who are
seeking to understand how the reasoning capabilities provided by RDFox can
enhance graph data management.</p>
<div class="section" id="computing-the-transitive-closure-of-a-relation">
<h3><span class="section-number">10.5.1. </span>Computing the Transitive Closure of a Relation<a class="headerlink" href="#computing-the-transitive-closure-of-a-relation" title="Permalink to this headline">¶</a></h3>
<p>In many other situations, we may have a relation that is not transitive, but we
are interested in defining a different relation that “transitively closes” it.
Consider a social network where users follow other users. The graph may be
represented by the triples next.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :follows :bob .
:bob :follows :charlie .
:diana :follows :alice .
</pre></div>
</div>
<p>A common task in social networks is to use existing connections to suggest new
ones. For example, since Alice follows Bob and Bob follows Charlie, the system
may suggest that Alice follow Charlie as well. Likewise, the system may suggest
that Diana follow Bob; but then, if Diana follows Bob, she may also want to
follow Charlie. We would like to construct an enhanced social network that
contains the actual follows relations plus all the suggested additional links.
The links in such enhanced social network represent the transitive closure of
the original follows relation, which relates any pair of people who are
connected by a path in the network. The transitive closure of the follows
relation can be computed using RDFox by defining the following two rules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :followsClosure, ?y] :- [?x, :follows, ?y] .

[?x, :followsClosure, ?z] :-
   [?x, :follows, ?y],
   [?y, :followsClosure, ?z] .
</pre></div>
</div>
<p>The first rule “copies” the contents of the direct follows relation to the new
relation. The second rule implements the closure by saying that if a person p1
directly follows p2 and p2 (directly or indirectly) follows person p3, then p1
(indirectly) follows p3.</p>
<p>If we now issue the SPARQL query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :followsClosure ?y }
</pre></div>
</div>
<p>we obtain the expected results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:diana :charlie .
:alice :charlie .
:diana :bob .
:alice :bob .
:bob :charlie .
:diana :alice .
</pre></div>
</div>
<p>Finally, we may also be interested in computing the suggested links that were
not already part of the original follows relation. This can be achieved, for
instance, by issuing the SPARQL query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y
WHERE {
   ?x :followsClosure ?y .
   FILTER NOT EXISTS { ?x :follows ?y }
}
</pre></div>
</div>
<p>The results are the expected ones.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:diana :charlie .
:alice :charlie .
:diana :bob .
</pre></div>
</div>
</div>
<div class="section" id="composing-relations">
<h3><span class="section-number">10.5.2. </span>Composing Relations<a class="headerlink" href="#composing-relations" title="Permalink to this headline">¶</a></h3>
<p>An important practical use of knowledge graphs is to power Open Query Answering
(Open QA) applications, where the user would pose a question in natural
language, which is then automatically answered against the graph. Open QA
systems often struggle to interpret questions that involve several “hops” in
the graph. For instance, consider the graph consisting of the triples given
next.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:douglas_adams :bornIn :uk .
:uk rdf:type :Country .
</pre></div>
</div>
<p>A user may ask the Open QA system for the country of birth of Douglas Adams. To
obtain this information, the system would need to construct a query involving
two hops in the graph. In particular, the SPARQL query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?c
WHERE {
  :douglas_adams :bornIn  ?c .
  ?c rdf:type :Country .
}
</pre></div>
</div>
<p>would return :uk as answer.</p>
<p>The results of the open QA system would be greatly enhanced if the desired
information had been available in just a single hop. RDFox rules can be used to
provide a clean solution in this situation. In particular, we can use rules to
define a new :countryOfBirth relation that provides a “shortcut” for directly
accessing the desired information.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :countryOfBirth, ?y] :- [?x, :bornIn, ?y], [?y, rdf:type, :Country] .
</pre></div>
</div>
<p>The rule says that, if a person p is born in a place c, and that place is a
country, then c is the country of birth of p. As a result, RDFox would derive
that the country of birth of Douglas Adams is the UK. The Open QA system would
now only need to construct the following simpler query, which involves a single
hop in the graph, to obtain the desired information.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :countryOfBirth ?y }
</pre></div>
</div>
</div>
<div class="section" id="representing-sparql-1-1-property-paths">
<span id="representing-property-paths"></span><h3><span class="section-number">10.5.3. </span>Representing SPARQL 1.1 Property Paths<a class="headerlink" href="#representing-sparql-1-1-property-paths" title="Permalink to this headline">¶</a></h3>
<p>Whilst RDFox does support SPARQL 1.1 property paths, in many situations a user can achieve
better performance by encoding them as rules instead.</p>
<p>Informally, a property path searches through the RDF graph for a sequence of
IRIs that form a path conforming to an regular expression. For instance, the
following query in our familiar social network example</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x :follows+ :bob }
</pre></div>
</div>
<p>returns the set of people that follow :bob directly or indirectly in the
network. In this case, the property path <code class="docutils literal notranslate"><span class="pre">(?x</span> <span class="pre">:follows+</span> <span class="pre">:bob)</span></code> represents a
path of arbitrary length from any node to :bob via the :follows relation, where
the <code class="docutils literal notranslate"><span class="pre">+</span></code> symbol is the familiar one in regular expressions indicating “one or
more occurrences”.</p>
<p>Property paths representing paths of arbitrary length are closely related to
computing the transitive closure of a relation. In particular, the following
rules would compute the set of “Bob followers” as those who follow :bob
directly or indirectly.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :BobFollower] :- [?x, :follows, :bob] .

[?x, rdf:type, :BobFollower] :-
   [?x, :follows, ?y],
   [?y, rdf:type, :BobFollower] .
</pre></div>
</div>
<p>The simple query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :BobFollower }
</pre></div>
</div>
<p>gives us the same answers as the original query using property paths.</p>
</div>
<div class="section" id="defining-a-query-as-a-view">
<h3><span class="section-number">10.5.4. </span>Defining a Query as a View<a class="headerlink" href="#defining-a-query-as-a-view" title="Permalink to this headline">¶</a></h3>
<p>When querying a knowledge graph, we may be interested in materializing the
result of a SPARQL query as a new relation in the graph. This can be the case,
for instance, if the query is interesting in its own right, can be used to
define new relations, or simplify the formulation of additional queries.</p>
<p>We can use an RDFox rule for this purpose, where the SPARQL query that we want
to materialize in the graph is represented in the body of the rule and the
answer as a new relation in the head.</p>
<p>For instance, consider again the previous example of a social network, where we
were interested in suggesting new followers (recall the Transitive Closure
usage pattern). Recall that we used a query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y
WHERE {
    ?x :followsClosure ?y
    FILTER NOT EXISTS { ?x :follows ?y }
}
</pre></div>
</div>
<p>to obtain the suggested links that were not already part of the original
follows relation. We may be interested in storing this query as a separate
relation in the graph. For this, we could rewrite the query as a rule defining
a new :suggestFollows relation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :suggestFollows, ?y] :- [?x, :followsClosure, ?y], NOT [?x, :follows, ?y] .
</pre></div>
</div>
<p>The body of the rule represents the <code class="docutils literal notranslate"><span class="pre">where</span></code> clause in the query. The filter
expression in the query is captured by the negated atom. Then, the simple query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :suggestFollows ?y }
</pre></div>
</div>
<p>will give us the expected answers</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:diana :charlie .
:alice :charlie .
:diana :bob .
</pre></div>
</div>
<p>It is worth pointing out that only a subset of SPARQL 1.1 queries can be
transformed into an RDFox rule in the way described. In particular, all queries
involving basic graph patterns, filter expressions, negation (<code class="docutils literal notranslate"><span class="pre">NOT</span> <span class="pre">EXISTS</span></code>,
<code class="docutils literal notranslate"><span class="pre">MINUS</span></code>) and aggregation can be represented. In contrast, SPARQL queries with
more than two answer variables, or using <code class="docutils literal notranslate"><span class="pre">OPTIONAL</span></code> or <code class="docutils literal notranslate"><span class="pre">UNION</span></code> in the
<code class="docutils literal notranslate"><span class="pre">WHERE</span></code> clause cannot be represented as rules.</p>
</div>
<div class="section" id="performing-calculations-and-aggregating-data">
<h3><span class="section-number">10.5.5. </span>Performing Calculations and Aggregating Data<a class="headerlink" href="#performing-calculations-and-aggregating-data" title="Permalink to this headline">¶</a></h3>
<p>RDFox rules can be used to perform computations over the data in a knowledge
graph and store the results in a different relation. For instance, consider a
graph with the following triples, specifying the height of different people in
cm.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :height &quot;165&quot;^^xsd:integer .
:bob :height &quot;180&quot;^^xsd:integer .
:diana :height &quot;168&quot;^^xsd:integer .
:emma :height &quot;165&quot;^^xsd:integer .
</pre></div>
</div>
<p>We would want to compute their height in feet, and record it in the graph by
adding suitable triples over a new relation. For this, we can import the
following RDFox rule.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :heightInFeet, ?y] :- [?x, :height, ?h], BIND(?h*0.0328  AS ?y) .
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">BIND</span></code> construct evaluates an expression and assigns the value of the
expression to a variable.</p>
<p>We can now query the graph for the newly introduced relation to obtain the list
of people and their height in both centimeters and feet.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?m ?f
WHERE {
    ?x :height ?m .
    ?x :heightInFeet ?f .
}
</pre></div>
</div>
<p>and obtain the expected answers</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:emma 165 5.412 .
:diana 168 5.5104 .
:bob 180 5.904 .
:alice 165 5.412 .
</pre></div>
</div>
<p>Rules can also be used to compute aggregated values (e.g., sums, counts,
averages, etc) over the graph and store the results in a new relation.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :follows :bob .
:bob :follows :charlie .
:diana :follows :alice .
:charlie :follows :alice.
:emma :follows :bob .
:alice rdf:type :Person .
:bob rdf:type :Person .
:charlie rdf:type :Person .
:diana rdf:type :Person .
:emma rdf:type :Person .
</pre></div>
</div>
<p>The graph contains also information about people’s hobbies, as represented by
the following triples.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :likes :tennis .
:bob :likes :music .
:diana :likes :swimming .
:charlie :likes :football .
:emma :likes :reading .
:tennis rdf:type :Sport .
:swimming rdf:type :Sport .
:football rdf:type :Sport .
</pre></div>
</div>
<p>We would like to count, for each person, the number of followers who enjoy
practicing a sport. RDFox provides aggregation constructs which enable these
kinds of computations.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?y, :sportyFollowerCnt, ?cnt] :-
    [?y, rdf:type, :Person],
    AGGREGATE(
        [?x, :follows, ?y],
        [?x, :likes, ?w],
        [?w, rdf:type, :Sport]
        ON ?y
        BIND COUNT(DISTINCT ?x) AS ?cnt) .
</pre></div>
</div>
<p>In particular, the rule states that, if p1 Is a person, then count all distinct
people who follow p1 and who like some sport, store the result in a count, and
store the result in the new <code class="docutils literal notranslate"><span class="pre">:sportyFollowerCnt</span></code> relation.</p>
<p>By issuing the following SPARQL query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?cnt WHERE { ?x :sportyFollowerCnt ?cnt }
</pre></div>
</div>
<p>We obtain that Bob has one sporty follower (Alice), whereas Alice has 2 sporty
followers (Diana and Charlie).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:bob 1 .
:alice 2 .
</pre></div>
</div>
<p>This type of computation is compatible with the computation of the transitive
closure of a relation. For instance, we may be interested in counting the
number of (direct or indirect) followers who are sporty. For this, we can use
RDFox rules to compute the transitive closure of the follows relation:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :followsClosure, ?y] :- [?x, :follows, ?y] .
[?x, :followsClosure, ?z] :- [?x, :follows, ?y], [?y, :followsClosure, ?z] .
</pre></div>
</div>
<p>And use the following rule to compute the desired count.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?y, :sportyFollowerClosureCnt, ?cnt] :-
    [?y, rdf:type, :Person],
    AGGREGATE(
        [?x, :followsClosure, ?y],
        [?x, :likes, ?w],
        [?w, rdf:type, :Sport]
        ON ?y
        BIND COUNT(DISTINCT ?x) AS ?cnt) .
</pre></div>
</div>
<p>The following SPARQL query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?cnt WHERE { ?x :sportyFollowerClosureCnt ?cnt }
</pre></div>
</div>
<p>Then provides the following results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:charlie 3 .
:bob 3 .
:alice 3 .
</pre></div>
</div>
<p>We observe that the count for Charlie does not seem quite right. Charlie is
followed directly only by Bob (who is not sporty); however, Bob is followed by
Alice (a sporty person) and Alice is followed by Diana (another sporty person).
Naturally, we would have obtained a count of 2; however, Charlie also follows
Alice and hence he transitively follows himself, thus the count of 3!. If we
wanted to prevent this situation, we can modify the second rule implementing
transitive closure to eliminate self-loops as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :followsClosure, ?z] :-
   [?x, :follows, ?y],
   [?y, :followsClosure, ?z],
   FILTER(?x != ?z) .
</pre></div>
</div>
<p>Now, our query before yields the expected results</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:charlie 2 .
:bob 3 .
:alice 2 .
</pre></div>
</div>
</div>
<div class="section" id="arranging-concepts-and-relations-in-a-hierarchical-structure">
<h3><span class="section-number">10.5.6. </span>Arranging Concepts and Relations in a Hierarchical Structure<a class="headerlink" href="#arranging-concepts-and-relations-in-a-hierarchical-structure" title="Permalink to this headline">¶</a></h3>
<p>A common use of ontologies is to arrange concepts (called classes in OWL 2) and
relations (called properties in OWL 2) in a subsumption hierarchy. For
instance, we may want to say that dogs and cats are mammals and that mammals
are animals. Such subsumption relationships can be easily represented using
RDFox rules.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Mammal] :- [?x, rdf:type, :Dog] .

[?x, rdf:type, :Mammal] :- [?x, rdf:type, :Cat] .

[?x, rdf:type, :Animal] :- [?x, rdf:type, :Mammal] .
</pre></div>
</div>
<p>Suppose that we have a graph with the following triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:max rdf:type :Dog .
:coco rdf:type :Cat .
:teddy rdf:type :Mammal .
</pre></div>
</div>
<p>Then, RDFox will deduce that Max and Coco are both mammals and therefore also
animals, and also that Teddy is an animal. In particular, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Animal }
</pre></div>
</div>
<p>yields the expected results</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:max .
:teddy .
:coco .
</pre></div>
</div>
<p>It is also often the case that concepts are “assigned” certain properties. For
instance, mammals have children which are also mammals. This is known as a
<em>range restriction</em> in the ontology jargon, and can be represented using the
following RDFox rule</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?y, rdf:type, :Mammal] :- [?x, rdf:type, :Mammal],[?x, :hasChild, ?y] .
</pre></div>
</div>
<p>If we now extend the graph with the following triples.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:max :hasChild :betsy .
:coco :hasChild :minnie .
</pre></div>
</div>
<p>RDFox will derive automatically that both Betsy and Minnie are also mammals
(and therefore also animals). Indeed, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Mammal }
</pre></div>
</div>
<p>Will yield the expected results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:max .
:betsy .
:minnie .
:teddy .
:coco .
</pre></div>
</div>
<p>In many applications, it is also useful to represent subsumption relations
between the edges in a knowledge graph, to specify that one relation is more
specific than the other. For instance, we may want to say that the
<code class="docutils literal notranslate"><span class="pre">:hasDaughter</span></code> relation is more specific than the <code class="docutils literal notranslate"><span class="pre">:hasChild</span></code> relation.
This can be represented using the following RDFox rule.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :hasChild, ?y] :- [?x, :hasDaughter, ?y] .
</pre></div>
</div>
<p>If we now add the following triple to the graph</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:betsy :hasDaughter :luna .
</pre></div>
</div>
<p>RDFox can infer that Luna is the child of Betsy and therefore she is also a
mammal, and an animal. Indeed, the previous query listing all mammals will now
also include <code class="docutils literal notranslate"><span class="pre">:luna</span></code> as an answer.</p>
</div>
<div class="section" id="detecting-cyclic-relations">
<h3><span class="section-number">10.5.7. </span>Detecting Cyclic Relations<a class="headerlink" href="#detecting-cyclic-relations" title="Permalink to this headline">¶</a></h3>
<p>A common task in knowledge graphs is to identify cyclic relationships. For
instance, partonomy relations are typically acyclic (e.g., if an engine is part
of a car we would not expect the car also to be part of the engine!). In these
cases, cycle detection may be needed to detect errors in the graph and thus
provide data validation.</p>
<p>A simple case of this pattern is when the relation we are checking for
cyclicity is naturally transitive. Such is the case, for instance of the partOf
relation. Consider the following graph:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:a :partOf :b .
:b :partOf :c .
:c :partOf :a .
</pre></div>
</div>
<p>The graph contains a cyclic path :a -&gt; :b -&gt; :c -&gt; :a. via the <code class="docutils literal notranslate"><span class="pre">:partOf</span></code>
relation. The relationship is naturally transitive and hence we can use the
corresponding pattern to define it as such.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, :partOf, ?z] :- [?x, :partOf, ?y], [?y, :partOf, ?z] .
</pre></div>
</div>
<p>The following SPARQL query now gives us which elements are part of others
(directly or indirectly)</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x :partOf ?y }
</pre></div>
</div>
<p>Which gives us the following results</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:a :a .
:c :c .
:b :b .
:a :c .
:b :a .
:c :b .
:c :a .
:b :c .
:a :b .
</pre></div>
</div>
<p>Cyclicity manifests itself by the presence of self-loops (e.g., <code class="docutils literal notranslate"><span class="pre">:a</span></code> is
derived to be a part of itself ). Hence, it is possible to detect that the part
of relation is cyclic by issuing the following SPARQL query.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ASK { ?x :partOf ?x }
</pre></div>
</div>
<p>Where the result comes true since the partonomy relation does have a self loop.</p>
<p>Alternatively, we could have defined the following additional rule.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[:partOf, rdf:type, :CyclicRelation] :- [?x, :partOf, ?x] .
</pre></div>
</div>
<p>Which tells us that if any object is determined to be a part of itself, then
the partonomy relation is cyclic.</p>
<p>We can now issue the following SPARQL query, which retrieves the list of cyclic
relations in the graph, which in this case consists of the relation :partOf.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :CyclicRelation }
</pre></div>
</div>
</div>
<div class="section" id="defining-attributes-and-relationships-as-mandatory">
<h3><span class="section-number">10.5.8. </span>Defining Attributes and Relationships as Mandatory<a class="headerlink" href="#defining-attributes-and-relationships-as-mandatory" title="Permalink to this headline">¶</a></h3>
<p>In knowledge graphs, data is typically incomplete.</p>
<p>For instance, suppose that the data in a knowledge graph has been obtained from
a variety of sources. The graph has different types of information about
people, such as their name, job title and so on. We notice that some people in
the graph have a date of birth, whereas others do not. Because of the nature of
our application, we would like to have the date of birth of each person
represented in the graph, and would like to find out which people are missing
this information; that is, we would like to make the presence of a date of
birth value mandatory for every person in the graph. In relational databases
this is typically solved by declaring an integrity constraint.</p>
<p>Consider the following graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :dob &quot;11/01/1987&quot;^^xsd:string .
:alice rdf:type :Person .
:bob   :dob &quot;23/07/1980&quot;^^xsd:string .
:bob rdf:type :Person .
:diana :height &quot;168&quot;^^xsd:integer .
:diana rdf:type :Person .
:emma  :dob &quot;10/02/1965&quot;^^xsd:string .
:emma rdf:type :Person .
:max rdf:type :Dog .
</pre></div>
</div>
<p>We can use the following rule to record absence of a date of birth for people.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, owl:Nothing] :-
   [?x, rdf:type, :Person],
   NOT EXISTS ?y IN ([?x, :dob, ?y]) .
</pre></div>
</div>
<p>The rule says that if a person p lacks a date of birth d, then p incurs in a
constraint violation. The constraint violation is recorded by making person p
an instance of the special owl:Nothing unary relation, which is also present in
the OWL 2 standard.</p>
<p>The following SPARQL query then correctly reports that Diana violates the
constraint (whereas Max does not because he is a dog).</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type owl:Nothing }
</pre></div>
</div>
<p>This type of computation combines well with type inheritance. For instance,
suppose that we add the following triple:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:charlie rdf:type :Student .
</pre></div>
</div>
<p>And the following rule stating that every student is a person</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Person] :- [?x, rdf:type, :Student] .
</pre></div>
</div>
<p>Then, the previous query will give as results</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:charlie .
:diana .
</pre></div>
</div>
<p>Indeed, since Charlie is a student, he is also a person; furthermore, Charlie
lacks date of birth information.</p>
<p>The meaning of the special class <code class="docutils literal notranslate"><span class="pre">owl:Nothing</span></code> is different in RDFox and the
OWL 2 standard. If one can derive from an OWL 2 ontology that that an object is
an instance of owl:Nothing, then the ontology is inconsistent and querying the
ontology becomes logically meaningless. Thus, the OWL 2 standard would require
users to modify the data and/or ontology to fix the inconsistency prior to
attempting to issue queries. Furthermore, it is worth noting that in OWL 2 it
is not possible to write statements that check for “absence of information”;
this is due to the monotonicity properties of OWL 2 as a fragment of
first-order logic.</p>
<p>In contrast, in RDFox, deriving an instance of owl:Nothing does not lead to a
logical inconsistency and the answers to queries remain perfectly meaningful.
In the pattern we have described, querying for owl:Nothing simply provides
users with the list of all nodes in the graph for which mandatory information
is missing. As a result, the user is warned rather than prevented from carrying
out a task such as issuing a query. For instance, if we were to ask a query to
RDFox such as the following</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Person }
</pre></div>
</div>
<p>We would still obtain the expected results (see below) despite the fact that
there are constraint violations in the data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice .
:charlie .
:emma .
:diana .
:bob .
</pre></div>
</div>
<p>This behavior is also different from relational databases, where the system
would typically reject updates that lead to a constraint violation. As already
mentioned, RDFox continues to operate normally and would accept any updates
although constraints are being violated. Of course, users are encouraged to
query the system in order to detect and rectify such violations.</p>
</div>
<div class="section" id="expressing-defaults-and-exceptions">
<h3><span class="section-number">10.5.9. </span>Expressing Defaults and Exceptions<a class="headerlink" href="#expressing-defaults-and-exceptions" title="Permalink to this headline">¶</a></h3>
<p>Rules can be used to write default statements (that is, statements that
normally hold in the absence of additional information). This is especially
useful to represent exceptions to rules, which is important, for instance, in
legal domains.</p>
<p>Consider the following graph saying that Tweety is a bird.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:tweety rdf:type :Bird .
</pre></div>
</div>
<p>Birds typically fly; that is, in the absence of additional information, the
fact that Tweety is a bird constitutes sufficient evidence to believe that
Tweety flies. There may, however, be exceptions. For instance, penguins are
birds that cannot fly, and hence if we were to find out that Tweety is a
penguin, then we would need to withdraw our default assumption that Tweety
flies.</p>
<p>RDFox rules can be used to model this type of <em>default</em> reasoning. In
particular, consider a rule saying that birds fly unless they are penguins.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :FlyingAnimal] :-
   [?x, rdf:type, :Bird],
   NOT [?x, rdf:type, :Penguin] .
</pre></div>
</div>
<p>We can now issue a SPARQL query asking for the list of flying animals</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :FlyingAnimal }
</pre></div>
</div>
<p>and obtain :tweety as an answer.</p>
<p>Suppose now that we were to extend the graph with the following triple</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:tweety rdf:type :Penguin .
</pre></div>
</div>
<p>Then, the same query would now give us an empty set of answers since, in the
light of the new evidence, we can no longer conclude that Tweety flies.</p>
</div>
<div class="section" id="restructuring-data">
<h3><span class="section-number">10.5.10. </span>Restructuring Data<a class="headerlink" href="#restructuring-data" title="Permalink to this headline">¶</a></h3>
<p>Rules can be used to transform the structure of the data in a knowledge graph
(e.g., by adding properties to a relationship).</p>
<p>Consider the following knowledge graph representing employees and their
employer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :worksFor :oxford_university .
:bob :worksFor :acme .
:charlie :worksFor :oxford_university .
:charlie :worksFor :acme .
</pre></div>
</div>
<p>Suppose that we now want to expand the graph by adding further information
about the employment, such as the salary and the start date. This information
is relative to each specific employment of an employee; for instance, Charlie
will have a different salary and start date for his employment with Oxford
University and his employment with Acme.</p>
<p>We can use RDFox rules to automatically restructure the data in the graph to
account for the new information. To this end, we use the built-in tuple table
<code class="docutils literal notranslate"><span class="pre">SKOLEM</span></code>, which allows us to associate a tuple of elements with a
unique blank node.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?employment, rdf:type, :Employment],
[?employment, :hasEmployee, ?employee],
[?employment, :hasEmployer, ?employer] :-
    [?employee, :worksFor, ?employer],
    SKOLEM(&quot;Employment&quot;, ?employee, ?employer, ?employment) .
</pre></div>
</div>
<p>For each <code class="docutils literal notranslate"><span class="pre">:worksFor</span></code> edge connecting a person <code class="docutils literal notranslate"><span class="pre">?employee</span></code> with their
employer <code class="docutils literal notranslate"><span class="pre">?employer</span></code>, the rule creates a blank node <code class="docutils literal notranslate"><span class="pre">?employment</span></code>, which is
unique for the tuple <code class="docutils literal notranslate"><span class="pre">(&quot;Employment&quot;,</span> <span class="pre">?employee,</span> <span class="pre">?employer)</span></code>. Furthermore, the
rule relates the blank node <code class="docutils literal notranslate"><span class="pre">?employment</span></code> to the entities <code class="docutils literal notranslate"><span class="pre">?employee</span></code> and
<code class="docutils literal notranslate"><span class="pre">?employer</span></code> using the <code class="docutils literal notranslate"><span class="pre">:hasEmployee</span></code> and <code class="docutils literal notranslate"><span class="pre">:hasEmployer</span></code> properties,
respectively.</p>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?employment ?property ?object WHERE {
    ?employment ?property ?object .
    ?employment rdf:type :Employment
}
</pre></div>
</div>
<p>gives us the new triples generated by the application of the previous rule</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>_:Employment_116_200 :hasEmployer :acme .
_:Employment_116_200 :hasEmployee :bob .
_:Employment_116_200 rdf:type :Employment .
_:Employment_113_199 :hasEmployer :oxford_university .
_:Employment_113_199 :hasEmployee :alice .
_:Employment_113_199 rdf:type :Employment .
_:Employment_156_199 :hasEmployer :oxford_university .
_:Employment_156_199 :hasEmployee :charlie .
_:Employment_156_199 rdf:type :Employment .
_:Employment_156_200 :hasEmployer :acme .
_:Employment_156_200 :hasEmployee :charlie .
_:Employment_156_200 rdf:type :Employment .
</pre></div>
</div>
<p>New data relative to an employment, such as associated salary and start date,
can be inserted using rules like the following ones.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?z, :hasSalary, &quot;60000&quot;^^xsd:integer] :- SKOLEM(&quot;Employment&quot;, :alice, :oxford_university, ?z) .
[?z, :hasSalary, &quot;55000&quot;^^xsd:integer] :- SKOLEM(&quot;Employment&quot;, :charlie, :oxford_university, ?z) .
[?z, :hasSalary, &quot;40000&quot;^^xsd:integer] :- SKOLEM(&quot;Employment&quot;, :charlie, :acme, ?z) .
[?z, :hasSalary, &quot;45000&quot;^^xsd:integer] :- SKOLEM(&quot;Employment&quot;, :bob, :acme, ?z) .
</pre></div>
</div>
<p>Note that each of these rules uses the <code class="docutils literal notranslate"><span class="pre">SKOLEM</span></code> built-in table in the
rule body to make sure that they match correctly to the generated triples
listed above.</p>
<p>To check that the salary data has been inserted correctly, we can issue the
query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x (SUM(?y) AS ?income)
WHERE {
   ?e :hasEmployee ?x .
   ?e :hasSalary ?y
}
GROUP BY ?x
</pre></div>
</div>
<p>which gives us the total yearly income for each person by summing up the salary
of each of their employments, giving the expected results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice 60000 .
:charlie 95000 .
:bob 45000 .
</pre></div>
</div>
<p>Data restructuring via <a class="reference external" href="https://www.w3.org/wiki/RdfReification/">reification</a> has multiple applications. In
particular, RDF can only represent directly binary relations and hence the
representation of higher arity relations is only possible through reification.
Reification is also needed if we want to qualify or annotate edges in a graph
(e.g., by adding weights, or dates, or other relevant properties).</p>
</div>
<div class="section" id="representing-ordered-relations">
<h3><span class="section-number">10.5.11. </span>Representing Ordered Relations<a class="headerlink" href="#representing-ordered-relations" title="Permalink to this headline">¶</a></h3>
<p>Many relations naturally imply some sort of order, and in such cases we are
often interested in finding the first and last elements of such orders. For
instance, consider the managerial structure of a company.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:alice :manages :bob .
:bob :manages :jeremy .
:bob :manages :emma .
:emma :manages :david .
:jeremy :manages :monica .
</pre></div>
</div>
<p>We would like to recognize which individuals in the company are “top level
managers”. We can use a rule to define a top level manager as a person who
manages someone and is not managed by anyone else.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :TopLevelManager] :-
   [?x, :manages, ?y],
   NOT EXISTS ?z IN ([?z, :manages, ?x]) .
</pre></div>
</div>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :TopLevelManager }
</pre></div>
</div>
<p>asking for the list of top level managers gives as <code class="docutils literal notranslate"><span class="pre">:alice</span></code> as the answer. We
can now use a rule to define “junior employees” as those who have a manager but
who themselves do not manage anyone else.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :JuniorEmployee] :-
   [?y, :manages, ?x],
   NOT EXISTS ?z IN ([?x, :manages, ?z]) .
</pre></div>
</div>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :JuniorEmployee }
</pre></div>
</div>
<p>Gives us <code class="docutils literal notranslate"><span class="pre">:monica</span></code> and <code class="docutils literal notranslate"><span class="pre">:david</span></code> as answers.</p>
<p>Prominent examples of ordered relations where we may be interested in finding
the top and bottom elements are partonomies (part-whole relations) and is-a
hierarchies.</p>
</div>
<div class="section" id="representing-equality-cliques">
<h3><span class="section-number">10.5.12. </span>Representing Equality Cliques<a class="headerlink" href="#representing-equality-cliques" title="Permalink to this headline">¶</a></h3>
<p>When integrating data from multiple sources using a knowledge graph, it is
usually the case that objects from different sources are identified to be the
same. In this setting, we want to be able to answer complex queries that span
across the different sources, and to easily identify the source where the
information came from. Additionally, we may not want to use the equality
predicate <code class="docutils literal notranslate"><span class="pre">owl:sameAs</span></code> to identify the objects since our rule set may contain
rules involving aggregation and/or negation-as-failure which cannot be used in
conjunction with equality.</p>
<p>For instance, assume that we are integrating sources s1, s2, and s3 containing
information about music artists and records. Assume that we have determined
(e.g., using entity resolution techniques or exploiting explicit links between
the sources) that “John Doe” in s1 is the same as “J. H. Doe” in s2 and “The
Blues King” in s3. We can represent these correspondences using a binary
relation ost:same which we define as reflexive, symmetric, and transitive using
RDFox rules as given next.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1:john_doe rdf:type s1:Artist .
s2:john_H_doe rdf:type s2:Performer .
s3:blues_king rdf:type s3:Musician .
s1:john_doe ost:same s2:john_H_doe .
s1:john_doe ost:same s3:blues_king .
s2:john_H_doe ost:same s3:blues_king .

[?x, ost:same, ?x] :- [?x, ost:same, ?y] .

[?y, ost:same, ?x] :- [?x, ost:same, ?y] .

[?x, ost:same, ?z] :- [?x, ost:same, ?y], [?y, ost:name, ?z] .
</pre></div>
</div>
<p>In these way, the aforementioned objects form a clique in the integrated graph.
Indeed, the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x ost:same ?y }
</pre></div>
</div>
<p>returns the answer</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s3:blues_king s2:john_H_doe .
s2:john_H_doe s3:blues_king .
s2:john_H_doe s2:john_H_doe .
s3:blues_king s3:blues_king .
s2:john_H_doe s1:john_doe .
s3:blues_king s1:john_doe .
s1:john_doe s1:john_doe .
s1:john_doe s3:blues_king .
s1:john_doe s2:john_H_doe .
</pre></div>
</div>
<p>In order to be able to query across artists from different sources, we want to
define a unique representative for the elements in the clique. A plausible
strategy is to first select the smallest individual according to some
pre-defined total order (the order itself is irrelevant, and we can choose for
example the order on IRIs provided by RDFox). To select the smallest object we
introduce the following rules.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, ost:comesBefore, ?y] :- [?x, ost:same, ?y], FILTER (?x &lt; ?y)  .

[?y, rdf:type, ost:NotSmallestInClique] :- [?x, ost:comesBefore, ?y] .

[?x, rdf:type, ost:SmallestInClique] :-
    [?x, ost:comesBefore, ?y],
    NOT [?x, rdf:type, ost:NotSmallestInClique] .
</pre></div>
</div>
<p>The first rule generates an order amongst the elements of the clique. The
second rule says that if ?x comes before ?y then ?y is not the smallest
element. The third rule finally identifies the smallest element in the clique.
The following query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x ost:comesBefore ?y }
</pre></div>
</div>
<p>reveals the generated order</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s2:john_H_doe s3:blues_king .
s1:john_doe s2:john_H_doe .
s1:john_doe s3:blues_king .
</pre></div>
</div>
<p>where s1:john_doe is correctly identified as the smallest element by the query.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type ost:SmallestInClique }
</pre></div>
</div>
<p>Now that we have identified an element of the clique we can create a
representative of the clique using the built-in table <code class="docutils literal notranslate"><span class="pre">SKOLEM</span></code>, as
given next.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?z, rdf:type, ost:Artist],
[?z, ost:represents, ?x] :-
    [?x, rdf:type, ost:SmallestInClique],
    SKOLEM(&quot;OSTArtist&quot;, ?x, ?z) .

[?x, ost:represents, ?z] :-
   [?x, ost:represents, ?y],
   [?y, ost:comesBefore, ?z] .
</pre></div>
</div>
<p>The first rule creates a blank node that is an <code class="docutils literal notranslate"><span class="pre">ost:Artist</span></code> and that
represents the smallest element in the clique. The second rule ensures that the
new blank node also represents every other element in the clique.</p>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?z ?x WHERE { ?z ost:represents ?x }
</pre></div>
</div>
<p>Yields the expected result.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>_:OSTArtist_2136 s2:john_H_doe .
_:OSTArtist_2136 s3:blues_king .
_:OSTArtist_2136 s1:john_doe .
</pre></div>
</div>
<p>It is possible to achieve the same results by using an optimized set of rules
that generates fewer triples. In particular, this optimized representation
avoids axiomatizing the ost:same property as reflexive and symmetric. Let’s
reconsider the data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>s1:john_doe rdf:type s1:Artist .
s2:john_H_doe rdf:type s2:Performer .
s3:blues_king rdf:type s3:Musician .
s1:john_doe ost:same s2:john_H_doe .
s1:john_doe ost:same s3:blues_king .
s2:john_H_doe ost:same s3:blues_king .
</pre></div>
</div>
<p>We now redefine directly the ost:comesBefore relation using the following rules</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, ost:comesBefore, ?y] :-
   [?x, ost:same, ?y],
   FILTER(?x &gt; ?y) .

[?x, ost:comesBefore, ?y] :-
   [?y, ost:same, ?x],
   FILTER(?x &gt; ?y) .

[?x, ost:comesBefore, ?z] :-
   [?x, ost:comesBefore, ?y],
   [?y, ost:comesBefore, ?z],
   FILTER(?x &gt; ?y) .

[?x, ost:comesBefore, ?y] :-
   [?z, ost:comesBefore, ?x],
   [?z, ost:comesBefore, ?y],
   FILTER(?x &gt; ?y) .
</pre></div>
</div>
<p>The query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y WHERE { ?x ost:comesBefore ?y }
</pre></div>
</div>
<p>reveals a generated order. Once we have the order, we proceed as before.</p>
</div>
<div class="section" id="populating-a-knowledge-graph-from-a-data-source">
<span id="id7"></span><h3><span class="section-number">10.5.13. </span>Populating a Knowledge Graph from a Data Source<a class="headerlink" href="#populating-a-knowledge-graph-from-a-data-source" title="Permalink to this headline">¶</a></h3>
<p>Rules can be used to bring information from an external data source into a
knowledge graph.</p>
<p>Data feeding a knowledge graph often stems from different types of external
data sources, such as relational databases. We can use RDFox rules to specify
how each record in the external data source corresponds to a set of nodes and
edges in the graph. RDFox allows us to load the information in an external data
source by means of a two-stage process. The first step is to register the data
source. For instance, consider the following data about the employees of ACME
corporation in a CSV file named <code class="docutils literal notranslate"><span class="pre">employee.csv</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>emp_id,emp_name,job_name,hire_date,salary
68319,KAYLING,PRESIDENT,,200000
66928,BLAZE,MANAGER,2017-05-01,90000
67453,JONES,ASSISTANT,2018-05-03,35000
</pre></div>
</div>
<p>We want to create a data source tuple table to allow access to the file with 5
arguments, one per column in the table, and with name <code class="docutils literal notranslate"><span class="pre">employee</span></code>. This can be
achieved using the following commands.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dsource register &quot;EmployeeDS&quot;        \
  type delimitedFile                 \
  file &quot;$(dir.root)csv/employee.csv&quot; \
  header true
</pre></div>
</div>
<p>The net result is that the employee.csv file is registered as an RDFox data
source. We called the data source EmployeeDS. Here, <code class="docutils literal notranslate"><span class="pre">file</span></code> specifies the path
to the file, and <code class="docutils literal notranslate"><span class="pre">header</span></code> indicates whether the file contains a header row.
At this point, we can check whether the data source has been registered
successfully by running the command</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dsource show EmployeeDS
</pre></div>
</div>
<p>to obtain the expected information</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Data source type name: delimitedFile
Data source name:      EmployeeDS
Parameters:            file   = employee.csv
                       header = true
------------------------------------------------------------
Table name:            employee.csv
Column 1:              emp_id     xsd:integer
Column 2:              emp_name   xsd:string
Column 3:              job_name   xsd:string
Column 4:              hire_date  xsd:string
Column 5:              salary     xsd:integer
------------------------------------------------------------
</pre></div>
</div>
<p>The next step creates the data source tuple table.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tupletable create employee                 \
   &quot;dataSourceName&quot; &quot;EmployeeDS&quot;            \
   &quot;columns&quot;        5                       \
    &quot;1&quot;             &quot;https://rdfox.com/examples/{1}_{2}&quot; \
    &quot;1.datatype&quot;    &quot;iri&quot;                   \
    &quot;2&quot;             &quot;{emp_name}&quot;            \
    &quot;2.datatype&quot;    &quot;string&quot;                \
    &quot;3&quot;             &quot;{job_name}&quot;            \
    &quot;3.datatype&quot;    &quot;string&quot;                \
    &quot;4&quot;             &quot;{hire_date}&quot;           \
    &quot;4.datatype&quot;    &quot;string&quot;                \
    &quot;4.if-empty&quot;    &quot;absent&quot;                \
    &quot;5&quot;             &quot;{salary}&quot;              \
    &quot;5.datatype&quot;    &quot;integer&quot;               \
    &quot;5.if-empty&quot;    &quot;absent&quot;
</pre></div>
</div>
<p>The name of the new table will be <code class="docutils literal notranslate"><span class="pre">employee</span></code> and it will contain 5 arguments.
The first argument provides an identifier for each employee as a composition of
the prefix’s IRI, the employee ID (first column in the data source) and the
employee name (second column). The remaining arguments are obtained from the
column of the corresponding name in the data source. Since not every employee
may have a hiring date or a known salary, the conditions “if-empty” indicate
that the corresponding argument in the RDFox relation will be left empty.</p>
<p>Once the tuple table has been created in RDFox, it can be queried in SPARQL and
used in rule bodies. To query it in SPARQL, we use an RDFox extension to SPARQL
which uses the <code class="docutils literal notranslate"><span class="pre">TT</span></code> syntax, where <code class="docutils literal notranslate"><span class="pre">TT</span></code> stands for tuple table. The SPARQL
query:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x ?y ?z ?u ?w WHERE { TT employee { ?x ?y ?z ?u ?w } }
</pre></div>
</div>
<p>Will return the following answers:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:68319_KAYLING &quot;KAYLING&quot; &quot;PRESIDENT&quot; UNDEF 200000 .
:66928_BLAZE &quot;BLAZE&quot; &quot;MANAGER&quot; &quot;01/05/2017&quot; 90000 .
:67453_JONES &quot;JONES&quot; &quot;ASSISTANT&quot; &quot;03/05/2018&quot; 35000 .
</pre></div>
</div>
<p>As we can see, the <code class="docutils literal notranslate"><span class="pre">UNDEF</span></code> entry represents that the value of the hiring date
for the first employee is missing. Now that we have the <code class="docutils literal notranslate"><span class="pre">employee</span></code> tuple
table set up, the next step would be to turn its data in the form of a graph.
For this we can use the following rule, where the <code class="docutils literal notranslate"><span class="pre">employee</span></code> tuple table
forms the antecedent and the generated edges in the graph based on it are
described in the consequent of the rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Employee],
[?x, :worksFor, :acme],
[?x, :hasName, ?y],
[?x, :hasJob, ?z],
[?x, :hiredOnDate, ?u],
[?x, :salary, ?w] :-
    employee(?x, ?y, ?z, ?u, ?w) .
</pre></div>
</div>
<p>The materialization of the rule generates a graph from the data in the
<code class="docutils literal notranslate"><span class="pre">employee</span></code> tuple table. The derived facts in the graph can now be used in
other rules to define additional concepts and relations. For instance, we can
add the rules stating that every employee is a person and every person with a
salary higher than £50,000 pays tax at a higher-rate.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Person ] :- [?x, rdf:type, :Employee ] .

[?x, :taxRate, :higher-rate] :- [?x, rdf:type, :Person],  [?x, :salary, ?y], FILTER(?y &gt; 50000) .
</pre></div>
</div>
<p>Now we can query the graph to obtain, for instance, the list of high income tax
payers.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x :taxRate :higher-rate }
</pre></div>
</div>
<p>And obtain the expected results.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:68319_KAYLING .
:66928_BLAZE .
</pre></div>
</div>
<p>Data can be imported from different data sources and merged together in the
graph. For instance, if we had a different employee table (e.g., for a
different department) in another CSV, we could register it as a new RDFox data
source and exploit a rule akin to the one before to further populate the binary
relations in the graph, as well as to create new ones.</p>
</div>
</div>
<div class="section" id="owl-2-support-in-rdfox">
<span id="owl-support"></span><h2><span class="section-number">10.6. </span>OWL 2 Support in RDFox<a class="headerlink" href="#owl-2-support-in-rdfox" title="Permalink to this headline">¶</a></h2>
<p>This section describes the support in RDFox for OWL 2—the W3C standard language
for representing ontologies.</p>
<div class="section" id="owl-2-ontologies">
<h3><span class="section-number">10.6.1. </span>OWL 2 Ontologies<a class="headerlink" href="#owl-2-ontologies" title="Permalink to this headline">¶</a></h3>
<p>An OWL 2 ontology is a formal description of a domain of interest. OWL 2
defines three different syntactic categories.</p>
<p>The first syntactic category are <em>Entities</em>, such as <em>classes</em>, <em>properties</em>
and <em>individuals</em>, which are identified by an IRI. <em>Classes</em> represent sets of
objects in the world; for instance, a class <code class="docutils literal notranslate"><span class="pre">:Person</span></code> can be used to
represent the set of all people. <em>Properties</em> represent binary relations, and
OWL 2 distinguishes between two different types of properties: <em>data
properties</em> describe relationships between objects and literal values (e.g.,
the data property <code class="docutils literal notranslate"><span class="pre">:age</span></code> can be used to represent a person’s age), whereas
<em>object properties</em> describe relationships between two objects (e.g., an object
property <code class="docutils literal notranslate"><span class="pre">:locatedIn</span></code> can be used to relate places to their locations).
Finally, <em>individuals</em> in OWL 2 are used to refer to concrete objects in the
world; for instance, the individual <code class="docutils literal notranslate"><span class="pre">:oxford</span></code> can be used to refer to the
city of Oxford.</p>
<p>The second syntactic category are <em>expressions</em>, which can be used to describe
complex classes and relations constructed in terms of simpler ones. For
instance the expression <code class="docutils literal notranslate"><span class="pre">ObjectUnionOf(</span> <span class="pre">:Cat</span> <span class="pre">:Dog)</span></code> represents the set of
animals that are either cats or dogs.</p>
<p>The third syntactic category are <em>axioms</em>, which are statements about entities
and expressions that are asserted to be true in the domain described. For
instance, the OWL 2 axiom <code class="docutils literal notranslate"><span class="pre">SubClassOf(:Scientist</span> <span class="pre">:Person)</span></code> states that every
scientist is a person by defining the class <code class="docutils literal notranslate"><span class="pre">:Scientist</span></code> to be a subclass of
the class <code class="docutils literal notranslate"><span class="pre">:Person</span></code>.</p>
<p>The main component of an OWL 2 ontology is a set of axioms. Ontologies can also
import other ontologies and contain annotations.</p>
<p>OWL 2 ontologies can be written using different syntaxes. RDFox can currently
load ontologies written in the <em>functional syntax</em> as well as ontologies
written in the <em>turtle syntax</em>.</p>
</div>
<div class="section" id="owl-2-ontologies-vs-rdfox-rules">
<h3><span class="section-number">10.6.2. </span>OWL 2 Ontologies vs. RDFox Rules<a class="headerlink" href="#owl-2-ontologies-vs-rdfox-rules" title="Permalink to this headline">¶</a></h3>
<p>OWL 2 and the rule language of RDFox are languages for knowledge representation
with well-understood formal semantics.</p>
<p>Both languages share a common core. That is, certain types of rules can be
equivalently rewritten as OWL 2 axioms and vice-versa. For instance, the
following axiom and rule both express that every scientist is also a person.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf(:Scientist :Person)
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Person] :- [?x, rdf:type, :Scientist] .
</pre></div>
</div>
<p>In particular, the OWL 2 specification describes the OWL 2 RL profile—a subset
of the OWL 2 language that is amenable to implementation via rule-based
technologies.</p>
<p>There are, however, many other aspects where OWL 2 and the rule language of
RDFox differ, and there are many constructs in OWL 2 that cannot be translated
as RDFox rules and vice-versa. For instance, OWL 2 can represent <em>disjunctive
knowledge</em>, i.e., we can write an OWL 2 axiom saying that every student is
either an undergraduate student, a graduate student, or a doctoral student:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf(:Student ObjectUnionOf(:UndergraduateSt :MscSt :DoctoralSt) )
</pre></div>
</div>
<p>RDFox rules, however, do not support disjunction. There are also many kinds of
rules in RDFox that cannot be expressed using OWL 2 axioms; these include, for
instance, rules involving features such as aggregation, negation-as-failure or
certain built-in functions; furthermore, there are also plain Datalog rules
that do not have a correspondence in OWL 2.</p>
</div>
<div class="section" id="loading-owl-2-ontologies-into-rdfox">
<h3><span class="section-number">10.6.3. </span>Loading OWL 2 Ontologies into RDFox<a class="headerlink" href="#loading-owl-2-ontologies-into-rdfox" title="Permalink to this headline">¶</a></h3>
<p>RDFox manages OWL ontologies in form of axioms written in the Functional-Style
Syntax of OWL. For example, one can load the following ontology into RDFox
using any of the available APIs for loading data.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Prefix(:=&lt;http://www.example.com/ontology1#&gt;)
Ontology( &lt;http://www.example.com/ontology1&gt;
      Annotation(rdfox:NamedGraph :graph1)
      SubClassOf( :Child :Person )
      SubClassOf( :Person ObjectUnionOf(:Child :Adult) )
)
</pre></div>
</div>
<p>This ontology contains two axioms. The first axiom states that every child is
also a person, and the second axiom states that every person is either a child
or an adult. The first axiom can be faithfully translated into RDFox rules,
whereas the second one cannot. RDFox provides a full API for OWL 2 and can
parse, store and manage all possible forms of OWL 2 axioms in Functional-Style
Syntax. As a result, RDFox will load both axioms, even though the second axiom
cannot be fully translated into rules.</p>
<p>To load the ontology in RDFox, we can initialize a data store (see the Getting
Started guide) and import a file in the usual way. For example, assuming that
the above ontology is stored in file <code class="docutils literal notranslate"><span class="pre">ontology.txt</span></code>, we can import the
ontology as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import ontology.txt
</pre></div>
</div>
<p>The ontology axioms are now loaded in the data store and kept internally in a
separate container for axioms. Moreover, after loading, the axioms are
translated into rules in order to facilitate reasoning. At this point, RDFox
will issue a warning saying that the second axiom cannot be translated into
rules. The rules obtained from axioms are kept separately from the rules
imported explicitly, and the two sets of rules are managed separately.</p>
<p>We can now import a Turtle file containing the following triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:jen rdf:type :Child .
:jen :hasParent :mary .
</pre></div>
</div>
<p>Finally, we can import the following RDFox rule saying that the parent of a
child is a person.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?y, rdf:type, :Person] :- [?x, :hasParent, ?y], [?x, rdf:type, :Child] .
</pre></div>
</div>
<p>Now, we are in a position to perform reasoning. For this we can issue a SPARQL
query asking for the list of all people:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Person }
</pre></div>
</div>
<p>To answer the query, RDFox will consider all imported triples together with all
rules added by the user and all rules obtained by the translation of OWL 2
axioms. In particular, the following rules and facts contribute to answering
the query, where the first rule comes from the translation of the first
ontology axiom as a rule (the second axiom in the ontology is ignored):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:jen rdf:type :Child .
:jen :hasParent :mary .

[?x, rdf:type, :Person] :- [?x, rdf:type, :Child] .

[?y, rdf:type, :Person] :- [?x, :hasParent, ?y], [?x, rdf:type, :Child] .
</pre></div>
</div>
<p>As a result, RDFox will return as answers both <code class="docutils literal notranslate"><span class="pre">:jen</span></code> and <code class="docutils literal notranslate"><span class="pre">:mary</span></code>. Indeed,
<code class="docutils literal notranslate"><span class="pre">:jen</span></code> is a child and hence also a person by the first rule; in turn,
<code class="docutils literal notranslate"><span class="pre">:mary</span></code> is the parent of <code class="docutils literal notranslate"><span class="pre">:jen</span></code> and hence also a person by the second rule.</p>
<p>The translation of OWL 2 axioms into rules for the purpose of reasoning is
performed on a best-effort basis. In particular, sometimes RDFox may not be
able to translate the whole of given axiom, but may still be able to translate
a part of it. For example, suppose that we add to our data store the following
axiom saying that every person is a human and also either an adult or a child:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf(:Person ObjectIntersectionOf(:Human ObjectUnionOf(:Child :Adult)))
</pre></div>
</div>
<p>RDFox will load the axiom correctly, but will again issue a warning due to the
use of disjunction in the axiom. Suppose that we now issue the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Human }
</pre></div>
</div>
<p>RDFox will correctly return both <code class="docutils literal notranslate"><span class="pre">:jen</span></code> and <code class="docutils literal notranslate"><span class="pre">:mary</span></code> as answers. Indeed, as
already explained, RDFox can deduce that both <code class="docutils literal notranslate"><span class="pre">:jen</span></code> and <code class="docutils literal notranslate"><span class="pre">:mary</span></code> are
persons. Now, although the last axiom we imported cannot be fully translated
into rules, RDFox will still be able to partly translate it into the following
rule:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Human] :- [?x, rdf:type, :Person] .
</pre></div>
</div>
<p>from which we can deduce that <code class="docutils literal notranslate"><span class="pre">:jen</span></code> and <code class="docutils literal notranslate"><span class="pre">:mary</span></code> are also humans.</p>
</div>
<div class="section" id="associating-ontologies-with-named-graphs">
<h3><span class="section-number">10.6.4. </span>Associating Ontologies with Named Graphs<a class="headerlink" href="#associating-ontologies-with-named-graphs" title="Permalink to this headline">¶</a></h3>
<p>In all examples thus far, all reasoning was performed within the default graph.
However, RDFox manages a separate set of axioms for each named graph, and these
axioms operate only on triples of the corresponding named graph. There is no
standard way to associate an OWL ontology with a specific named graph. Thus,
RDFox uses a proprietary extension: an ontology is associated with a named
graph by annotating the ontology with the <code class="docutils literal notranslate"><span class="pre">rdfox:NamedGraph</span></code> annotation
property and an IRI or string literal containing the full name of the named
graph. If an ontology does not contain such an annotation, it is associated
with the default graph. For example, the annotation on the following ontology
instructs RDFox to load the ontology into named graph <code class="docutils literal notranslate"><span class="pre">:graph1</span></code>; after doing
so, the axioms are applicable to triples in that named graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Prefix(:=&lt;http://www.example.com/ontology1#&gt;)
Prefix(rdfox:=&lt;https://rdfox.com/vocabulary#&gt;)
Ontology( &lt;http://www.example.com/ontology1&gt;
      Annotation(rdfox:NamedGraph :graph1)
      SubClassOf( :Child :Person )
      SubClassOf( :Person ObjectUnionOf(:Child :Adult) )
)
</pre></div>
</div>
</div>
<div class="section" id="loading-ontologies-from-triples">
<span id="loading-owl-from-triples"></span><h3><span class="section-number">10.6.5. </span>Loading Ontologies from Triples<a class="headerlink" href="#loading-ontologies-from-triples" title="Permalink to this headline">¶</a></h3>
<p>An OWL 2 ontology can also be loaded from triples that use the <a class="reference external" href="https://www.w3.org/TR/2012/REC-owl2-mapping-to-rdf-20121211/">standard
representation of OWL 2 ontologies as triples</a>. This process
involves two steps.</p>
<ul class="simple">
<li><p>First, the triples are loaded into the default or any named graph.</p></li>
<li><p>Second, RDFox is instructed to parse this named graph, extract the axioms,
and add them to the same or a different named graph.</p></li>
</ul>
<p>For example, we can import the following triples into the named graph
<code class="docutils literal notranslate"><span class="pre">:Ontology</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Child rdfs:subClassOf :Person .
:Person rdfs:subClassOf :Human .
</pre></div>
</div>
<p>The following command says to RDFox to parse the graph <code class="docutils literal notranslate"><span class="pre">:Ontology</span></code> for OWL
axioms, and add the result to the graph <code class="docutils literal notranslate"><span class="pre">:Data</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>importaxioms :Ontology &gt; :Data
</pre></div>
</div>
<p>The effect of this command is the same as if the following OWL axioms in
Functional-Style Syntax were imported directly into the <code class="docutils literal notranslate"><span class="pre">:Data</span></code> named graph.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf( :Child :Person )
SubClassOf( :Person :Human )
</pre></div>
</div>
<p>As a result of this, RDFox will also transform these axioms into the following
rules.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Person[?x] :Data :- :Child[?x] :Data .

:Human[?x] :Data :- :Person[?x] :Data .
</pre></div>
</div>
<p>These rules will be taken into account when computing the materialisation.
Thus, if graph <code class="docutils literal notranslate"><span class="pre">:Data</span></code> contains triple <code class="docutils literal notranslate"><span class="pre">:jen</span> <span class="pre">rdf:type</span> <span class="pre">:Child</span> <span class="pre">.</span></code>, the
following query asking for the list of all humans will return <code class="docutils literal notranslate"><span class="pre">:jen</span></code> as
answer.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { GRAPH :Data { ?x rdf:type :Human } }
</pre></div>
</div>
<p>As with general importation operations, it is possible to specify that the
axioms represented as triples in the source named graph should be subtracted
from, rather than added to, the axioms of the target named graph. The following
command achieves the reverse of the example <code class="docutils literal notranslate"><span class="pre">importaxioms</span></code> command above
(assuming that the triples stored in graph <code class="docutils literal notranslate"><span class="pre">:Ontology</span></code> have not changed in
between):</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>importaxioms :Ontology &gt; :Data -
</pre></div>
</div>
<p>The rules derived as a result of the additive import will be automatically
retracted as a result of subtractive import.</p>
</div>
<div class="section" id="subsumption-reasoning">
<span id="appendix-internal-rule-domain"></span><h3><span class="section-number">10.6.6. </span>Subsumption Reasoning<a class="headerlink" href="#subsumption-reasoning" title="Permalink to this headline">¶</a></h3>
<p>OWL 2 reasoners implement a wide range of reasoning services, which are not
limited to query answering. In particular, OWL reasoners can solve the
subsumption problem: given a class, they would compute all its inferred
superclasses.</p>
<p>For example, given</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf( :Child :Person )
SubClassOf( :Person :Human )
</pre></div>
</div>
<p>an OWL 2 reasoner would be able to infer</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf( :Child :Human )
</pre></div>
</div>
<p>as a consequence, since from the fact that every child is a person, and every
person is a human, that every child is also a human.</p>
<p>RDFox is a materialization-based query answering system, and it has not been
designed for solving problems such as class subsumption. RDFox, however, is
still able to detect some such subsumption relations should this be required in
an application.</p>
<p>One way to achieve this is to reduce subsumption to query answering. In
particular, to check whether it is true that every child is a human, we can
introduce a fresh object in the data store, which we make an instance of
<code class="docutils literal notranslate"><span class="pre">:Child</span></code>. That is, we can import the following triple, where <code class="docutils literal notranslate"><span class="pre">:a_child</span></code> is
a fresh URI.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:a_child rdf:type :Child .
</pre></div>
</div>
<p>Then, we would test whether <code class="docutils literal notranslate"><span class="pre">:a_child</span></code> is inferred to be also a human by
issuing the query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>ASK { :a_child rdf:type :Human }
</pre></div>
</div>
<p>which would return true.</p>
<p>Another way of testing subsumption is to import the ontology as a set of
triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Child rdfs:subClassOf :Person .
:Person rdfs:subClassOf :Human .
</pre></div>
</div>
<p>Moreover, one can import a simple, builtin rule set for subsumption reasoning
by running the following shell command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import &lt;rdfox:TBoxReasoning&gt;
</pre></div>
</div>
<p>or through equivalent operations for importing from IRIs in REST and Java APIs (as described in <a class="reference internal" href="apis.html#apis-adding-data"><span class="std std-numref">Section 16.10.2.2</span></a>).</p>
<p>Note that this requires the proprietary URL scheme <code class="docutils literal notranslate"><span class="pre">rdfox</span></code> to appear in the
<code class="docutils literal notranslate"><span class="pre">allowed-schemes-on-load</span></code> setting for the containing RDFox Server (as it does
by default). See <a class="reference internal" href="servers.html#server-parameters"><span class="std std-numref">Section 4.3</span></a> for more information about this
and other server parameters.</p>
<p>The rules of <code class="docutils literal notranslate"><span class="pre">&lt;rdfox:TBoxReasoning&gt;</span></code> partially encode the semantics of the RDFS
and OWL vocabularies; in particular, it will add rules representing the
relation <code class="docutils literal notranslate"><span class="pre">rdfs:subClassOf</span></code> as transitive and reflexive, and also saying that
every class is a subclass of <code class="docutils literal notranslate"><span class="pre">owl:Thing</span></code>. As a result, the following SPARQL
query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { :Child rdfs:subClassOf ?x }
</pre></div>
</div>
<p>will correctly return all superclasses of <code class="docutils literal notranslate"><span class="pre">:Child</span></code> as</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Person .
:Human .
owl:Thing .
:Child .
</pre></div>
</div>
</div>
<div class="section" id="current-limitations">
<h3><span class="section-number">10.6.7. </span>Current Limitations<a class="headerlink" href="#current-limitations" title="Permalink to this headline">¶</a></h3>
<p>The following details should be taken into account by users of RDFox who rely
on OWL 2 ontologies in their applications:</p>
<ul class="simple">
<li><p>RDFox currently does not support ontology importation. That is, if we load
ontology O, which in turns imports O1 and O2, only the contents of O will be
loaded (and not those of O1 and O2).</p></li>
<li><p>RDFox also does not support associating axioms to a given ontology. In
particular, if we load two different ontology files, all the axioms in both
ontologies will be added to the same bag of axioms associated with a named
graph.</p></li>
</ul>
</div>
</div>
<div class="section" id="swrl-support-in-rdfox">
<h2><span class="section-number">10.7. </span>SWRL Support in RDFox<a class="headerlink" href="#swrl-support-in-rdfox" title="Permalink to this headline">¶</a></h2>
<p>This section describes the support in RDFox for <a class="reference external" href="https://www.w3.org/Submission/SWRL/">SWRL</a>—a format for representing rules on the
Semantic Web.</p>
<div class="section" id="swrl-rules">
<h3><span class="section-number">10.7.1. </span>SWRL Rules<a class="headerlink" href="#swrl-rules" title="Permalink to this headline">¶</a></h3>
<p>The SWRL specification extends the set of OWL axioms to include also Datalog
rules. It thus enables rules to be combined with an OWL ontology. SWRL rules
can be written using different syntaxes. RDFox can currently load SWRL rules
written in the functional syntax as well as rules written in the turtle syntax.
SWRL rules can be easily expressed as RDFox rules, with the only exception of
rules containing certain  built-ins which  do not have a direct correspondence
to SPARQL 1.1 built-in functions.</p>
</div>
<div class="section" id="loading-swrl-rules-in-rdfox">
<h3><span class="section-number">10.7.2. </span>Loading SWRL Rules in RDFox<a class="headerlink" href="#loading-swrl-rules-in-rdfox" title="Permalink to this headline">¶</a></h3>
<p>RDFox treats SWRL as an extension of OWL 2 and hence SWRL rules are loaded and
managed in exactly the same way as OWL 2 axioms. For instance, consider the
following text file <code class="docutils literal notranslate"><span class="pre">swrl-rules.txt</span></code> containing an ontology written in the
functional syntax of SWRL:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Prefix(:=&lt;http://www.example.com/ontology1#&gt;)
Ontology( &lt;http://www.example.com/ontology1&gt;
      Implies(Antecedent(:Student(I-variable(:x1))) Consequent(:Person(I-variable(:x1))))
)
</pre></div>
</div>
<p>The ontology consists of a rule stating that every student is a person.</p>
<p>To load the ontology in RDFox, we can initialize a data store (see the Getting
Started guide) and import the the file in the usual way.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import swrl-rules.txt
</pre></div>
</div>
<p>The SWRL rule is now loaded in the data store and kept internally in the
“axioms bag”.</p>
<p>We can next import a turtle file containing the triple:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:jen rdf:type :Student .
</pre></div>
</div>
<p>Now, we are in a position to perform reasoning. For this we can issue a SPARQL
query asking for the list of all people:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :Person }
</pre></div>
</div>
<p>To answer the query, RDFox will translate SWRL into RDFox rules, and will
return <code class="docutils literal notranslate"><span class="pre">:jen</span></code> as a result.</p>
<p>SWRL can also be loaded from a turtle file, following the relevant syntax in
the SWRL specification. For this, RDFox follows exactly the same approach as
with OWL 2 axioms expressed as triples (see <a class="reference internal" href="#loading-owl-from-triples"><span class="std std-numref">Section 10.6.5</span></a>).</p>
</div>
<div class="section" id="negation-as-failure-in-swrl">
<span id="swrl-naf-description"></span><h3><span class="section-number">10.7.3. </span>Negation-As-Failure in SWRL<a class="headerlink" href="#negation-as-failure-in-swrl" title="Permalink to this headline">¶</a></h3>
<p>By default SWRL rules that feature <code class="docutils literal notranslate"><span class="pre">ObjectComplementOf</span></code> are rejected by
RDFox, since negation in RDFox is interpreted under the closed-world
assumption, while negation in SWRL is interpreted under the open-world
assumption.</p>
<p>This behavior can be overridden by initializing a store with the option
<code class="docutils literal notranslate"><span class="pre">swrl-negation-as-failure</span></code> set to <code class="docutils literal notranslate"><span class="pre">on</span></code>, as described in
<a class="reference internal" href="data-stores.html#swrl-naf-option"><span class="std std-numref">Section 5.4.1.9</span></a>.</p>
<blockquote>
<div><div class="example docutils container">
<p><strong>Example:</strong> Consider, for example, the following SWRL rule with a suitably defined default prefix</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Implies (
    Antecedent (
        :A(I-variable(:x))
        ObjectComplementOf(:B)(I-variable(:x))
    )
    Consequent(:C(I-variable(:x)))
)
</pre></div>
</div>
<p>If a store is initialized with the option <code class="docutils literal notranslate"><span class="pre">swrl-negation-as-failure</span>
<span class="pre">on</span></code>, RDFox will convert the above SWRL rule to the following RDFox rule</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:C[?x] :- :A[?x], NOT :B[?x] .
</pre></div>
</div>
</div>
</div></blockquote>
<p>The feature is limited to class expressions of the form
<code class="docutils literal notranslate"><span class="pre">ObjectComplementOf(C)</span></code>, where <code class="docutils literal notranslate"><span class="pre">C</span></code> is a class name. The usage of
<code class="docutils literal notranslate"><span class="pre">ObjectComplementOf</span></code> in complex class expressions or in the consequent of a
SWRL rule is not supported.</p>
</div>
<div class="section" id="id8">
<h3><span class="section-number">10.7.4. </span>Current Limitations<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h3>
<p>SWRL comes with a large number of built-in functions, but unfortunately only a
subset of them maps directly to SPARQL 1.1 built-in functions, which are the
those natively supported in RDFox.</p>
<p>The list of built-in functions not supported is as follows:
<code class="docutils literal notranslate"><span class="pre">swrlb:roundHalfToEven</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:normalizeSpace</span></code>,  <code class="docutils literal notranslate"><span class="pre">swrlb:translate</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:anyURI</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:tokenize</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:yearMonthDuration</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:dayTimeDuration</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:dateTime</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:date</span></code>,  <code class="docutils literal notranslate"><span class="pre">swrlb:time</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:addYearMonthDurations</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:subtractYearMonthDurations</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:multiplyYearMonthDuration</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:divideYearMonthDurations</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:addDayTimeDurations</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:subtractDayTimeDurations</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:multiplyDayTimeDurations</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:divideDayTimeDuration</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDates</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:subtractTimes</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:addYearMonthDurationToDateTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:addDayTimeDurationToDateTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractYearMonthDurationFromDateTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDayTimeDurationFromDateTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:addYearMonthDurationToDate</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:addDayTimeDurationToDate</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractYearMonthDurationFromDate</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDayTimeDurationFromDate</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:addDayTimeDurationToTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDayTimeDurationFromTime</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDateTimesYieldingYearMonthDuration</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:subtractDateTimesYieldingDayTimeDuration</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:listConcat</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:listIntersection</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:listSubtraction</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:member</span></code>,
<code class="docutils literal notranslate"><span class="pre">swrlb:length</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:first</span></code>,  <code class="docutils literal notranslate"><span class="pre">swrlb:rest</span></code>, <code class="docutils literal notranslate"><span class="pre">swrlb:sublist</span></code>, and
<code class="docutils literal notranslate"><span class="pre">swrlb:empty</span></code>.</p>
</div>
</div>
<div class="section" id="explaining-reasoning-results">
<span id="id9"></span><h2><span class="section-number">10.8. </span>Explaining Reasoning Results<a class="headerlink" href="#explaining-reasoning-results" title="Permalink to this headline">¶</a></h2>
<p>RDFox can display a proof of how a given triple has been derived. Such proofs
can be very useful for explaining reasoning results to users as well as for
understanding the reasoning process.</p>
<p>Consider a data store containing the triple</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:kiki rdf:type :Cat .
</pre></div>
</div>
<p>and the following rules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Mammal] :- [?x, rdf:type, :Cat] .

[?x, rdf:type, :Animal] :- [?x, rdf:type, :Mammal] .
</pre></div>
</div>
<p>As a result of reasoning, RDFox will derive the following new triples:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:kiki rdf:type :Mammal .
:kiki rdf:type :Animal .
</pre></div>
</div>
<p>Suppose that we want to understand how triple <code class="docutils literal notranslate"><span class="pre">:kiki</span> <span class="pre">rdf:type</span> <span class="pre">:Animal</span></code> has
been derived. A way to do this in RDFox is to use the <code class="docutils literal notranslate"><span class="pre">explain</span></code> command in
the shell as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>explain :Animal[:kiki]
</pre></div>
</div>
<p>RDFox will explicate the reasoning process by displaying the following proof of
the requested fact:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Animal[:kiki]
    :Animal[?x] :- :Mammal[?x] .  | { ?x -&gt; :kiki }
        :Mammal[:kiki]
            :Mammal[?x] :- :Cat[?x] .  | { ?x -&gt; :kiki }
                :Cat[:kiki]  EXPLICIT
</pre></div>
</div>
<p>We can read the proof bottom-up. Starting from fact <code class="docutils literal notranslate"><span class="pre">:Cat[:kiki]</span></code> in the
data, we apply rule <code class="docutils literal notranslate"><span class="pre">:Mammal[?x]</span> <span class="pre">:-</span> <span class="pre">:Cat[?x]</span></code> by matching variable <code class="docutils literal notranslate"><span class="pre">?x</span></code> to
<code class="docutils literal notranslate"><span class="pre">:kiki</span></code> and derive the fact <code class="docutils literal notranslate"><span class="pre">:Mammal[:kiki]</span></code>. The application of rule
<code class="docutils literal notranslate"><span class="pre">:Animal[?x]</span> <span class="pre">:-</span> <span class="pre">:Mammal[?x]</span></code> to fact <code class="docutils literal notranslate"><span class="pre">:Mammal[:kiki]</span></code> where <code class="docutils literal notranslate"><span class="pre">?x</span></code> is
matched to <code class="docutils literal notranslate"><span class="pre">:kiki</span></code> yields the desired result.</p>
<p>Typically, there will be several different proofs for a given fact. To see
this, suppose that we add to our data store the triples</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:kiki :eats :luxury_pet_treat .
:luxury_pet_treat rdf:type :PetFood .
</pre></div>
</div>
<p>and the rule</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :Animal] :- [?x, :eats, ?y], [?y, rdf:type, :PetFood] .
</pre></div>
</div>
<p>Then, in addition to the previous one, the following is also a proof that
<code class="docutils literal notranslate"><span class="pre">:kiki</span></code> is an animal:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Animal[:kiki]
    :Animal[?x] :- :eats[?x,?y], :PetFood[?y] .  | { ?x -&gt; :kiki, ?y -&gt; :luxury_pet_treat }
        :eats[:kiki,:luxury_pet_treat]  EXPLICIT
        :PetFood[:luxury_pet_treat]  EXPLICIT
</pre></div>
</div>
<p>Indeed, we can match rule <code class="docutils literal notranslate"><span class="pre">:Animal[?x]</span> <span class="pre">:-</span> <span class="pre">:eats[?x,</span> <span class="pre">?y],</span> <span class="pre">:PetFood[?y]</span></code> to the
data facts <code class="docutils literal notranslate"><span class="pre">:eats[:kiki,</span> <span class="pre">:luxury_pet_treat]</span></code> and
<code class="docutils literal notranslate"><span class="pre">:PetFood[:luxury_pet_treat]</span></code> by matching variable <code class="docutils literal notranslate"><span class="pre">?x</span></code> to <code class="docutils literal notranslate"><span class="pre">:kiki</span></code> and
variable <code class="docutils literal notranslate"><span class="pre">?y</span></code> to <code class="docutils literal notranslate"><span class="pre">:luxury_pet_treat</span></code> to derive <code class="docutils literal notranslate"><span class="pre">:Animal[:kiki]</span></code>.</p>
<p>If we run again the explanation command</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>explain :Animal[:kiki]
</pre></div>
</div>
<p>RDFox will display <em>both</em> proofs.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Animal[:kiki]
    :Animal[?x] :- :Mammal[?x] .  | { ?x -&gt; :kiki }
        :Mammal[:kiki]
            :Mammal[?x] :- :Cat[?x] .  | { ?x -&gt; :kiki }
                :Cat[:kiki]  EXPLICIT
    :Animal[?x] :- :eats[?x,?y], :PetFood[?y] .  | { ?x -&gt; :kiki, ?y -&gt; :luxury_pet_treat }
        :eats[:kiki,:luxury_pet_treat]  EXPLICIT
        :PetFood[:luxury_pet_treat]  EXPLICIT
</pre></div>
</div>
<p>Since the number of possible different proofs for a given fact may be very
large, we may be content with just obtaining a single one. We can use the
explain command to obtain a shortest proof as follows:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>explain shortest :Animal[:kiki]
</pre></div>
</div>
<p>which will return the following proof</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Animal[:kiki]
    :Animal[?x] :- :eats[?x,?y], :PetFood[?y] .  | { ?x -&gt; :kiki, ?y -&gt; :luxury_pet_treat }
        :eats[:kiki,:luxury_pet_treat]  EXPLICIT
        :PetFood[:luxury_pet_treat]  EXPLICIT
</pre></div>
</div>
<p>Indeed, this is the shortest proof as it involves a single rule application,
whereas the alternative proof involves two rule applications.</p>
<p>When using the explanation command, it is important to understand that rules in
RDFox can come from different sources</p>
<ul class="simple">
<li><p><em>User rules</em> such as the ones in our previous example are rules introduced
directly by the user.</p></li>
<li><p><em>User axioms</em> are OWL 2 axioms imported by the user, which are internally
translated into rules.</p></li>
<li><p><em>Special rules</em> are rules that have no direct connection with the information
provided by the user and are internally added by RDFox. An example of special
rules are the rules for subsumption reasoning provided at the end of the
previous section, and another example are the rules obtained by axiomatizing
equality as a transitive, reflexive and symmetric relation.</p></li>
</ul>
<p>Consider for example a data store where we import the following triple: <code class="docutils literal notranslate"><span class="pre">:kiki</span>
<span class="pre">rdf:type</span> <span class="pre">:Cat</span> <span class="pre">.</span></code> and also the following OWL 2 axioms in functional syntax</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SubClassOf( :Cat :Mammal )
SubClassOf( :Mammal :Animal )
</pre></div>
</div>
<p>If we now run the explain command</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>explain :Animal[:kiki]
</pre></div>
</div>
<p>we obtain the same proof as before:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:Animal[:kiki]
    :Animal[?X] :- :Mammal[?X] .  | { ?X -&gt; :kiki }
        :Mammal[:kiki]
            :Mammal[?X] :- :Cat[?X] .  | { ?X -&gt; :kiki }
                :Cat[:kiki]  EXPLICIT
</pre></div>
</div>
<p>It is important to note, however, that the explicitly given OWL 2 axioms are
not displayed in the proof, but rather the rules that are obtained from them
internally.</p>
<div class="section" id="format-encoding-explanation-of-reasoning">
<h3><span class="section-number">10.8.1. </span>Format Encoding Explanation of Reasoning<a class="headerlink" href="#format-encoding-explanation-of-reasoning" title="Permalink to this headline">¶</a></h3>
<p>RDFox uses a JSON-based format to capture explanation of reasoning. The MIME
type of the format is <code class="docutils literal notranslate"><span class="pre">application/x.explanation+json</span></code>. The structure of this
format is described in <a class="reference internal" href="apis.html#apis-explaining-reasoning"><span class="std std-numref">Section 16.17</span></a>.</p>
</div>
<div class="section" id="explanation-in-the-web-console">
<span id="explanation-in-web-console"></span><h3><span class="section-number">10.8.2. </span>Explanation in the Web Console<a class="headerlink" href="#explanation-in-the-web-console" title="Permalink to this headline">¶</a></h3>
<p>The Console provides a mode for fetching, and then visualizing, an explanation
from RDFox. This may be accessed from from a context menu on an edge
representing a derived fact in the Explore mode. Alternatively the “Explain”
mode may be selected on the mode selector at the top right of the Console, and
the fact to explain entered in the text field in Datalog syntax.</p>
<p>The explanation fetched will always be a “shortest proof”
(<a class="reference internal" href="#explaining-reasoning-results"><span class="std std-numref">Section 10.8</span></a>).</p>
<p>The Explain mode is divided into three panes.</p>
<p><a class="reference internal" href="_images/explanation-screenshot.png"><img alt="Screenshot of Explain mode consisting of a toolbar and three resizable panes." src="_images/explanation-screenshot.png" style="width: 1100px;" /></a></p>
<p>The <strong>proof tree</strong> on the left shows the structure of the explanation as a
hierarchy of derived facts, where the leaf nodes of the tree are the supporting
explicit facts.</p>
<p>Selecting a derived fact on the tree by clicking it displays the rule that
derived it in the details pane. If the fact is a triple, a checkbox next to the
rule may also be selected to display the fact on the graph view. If a fact is
both selected in the tree and its checkbox is ticked, then the fact displayed
in the graph view is highlighted.</p>
<p>In addition to facts, noteworthy fragments of rules that derived each fact are
displayed beneath each fact, with variables replaced with the substitutions in
the explanation.</p>
<p>The <strong>graph view</strong> contains the triples checked in the proof tree, and may
provide a visual aid to the understanding of the explanation. The edges of the
graph may be selected to select the corresponding fact in the proof tree.
Context menus on the nodes and edges allow transition to new “Explore” and
“Explain” sessions respectively.</p>
<p>The <strong>details pane</strong> displays a Datalog rule associated with the fact or rule
fragment selected in the proof tree.</p>
<ul class="simple">
<li><p>If a derived fact is selected, the rule that derived the fact is shown, with
the relevant head atom highlighted.</p></li>
<li><p>If an explicit fact is selected, the rule which derived the fact immediately
above it in the tree is shown, and the relevant body atom (for the selected
fact) is highlighted.</p></li>
<li><p>If a filter, aggregate, negation or bind atom is selected, the containing
rule is shown with the selected atom highlighted.</p></li>
</ul>
<p>In each case the rule can be shown as Datalog (“Unbound”) or with the
substitutions from the explanation in place of the variables (“Grounded”).</p>
</div>
</div>
<div class="section" id="monitoring-reasoning-in-rdfox">
<span id="reasoning-monitoring"></span><h2><span class="section-number">10.9. </span>Monitoring Reasoning in RDFox<a class="headerlink" href="#monitoring-reasoning-in-rdfox" title="Permalink to this headline">¶</a></h2>
<p>This section gives an overview of the different ways of analyzing the rules in
RDFox and monitoring the reasoning progress. For this section we will be using
the <a class="reference external" href="https://github.com/OxfordSemantic/RDFoxWorkshop/tree/7ea307b620e8c50ef1831c658d915c1fbca484d9">F1 demo dataset</a>.</p>
<div class="section" id="inspecting-rules-in-rdfox">
<h3><span class="section-number">10.9.1. </span>Inspecting Rules in RDFox<a class="headerlink" href="#inspecting-rules-in-rdfox" title="Permalink to this headline">¶</a></h3>
<p>We begin by describing how to use the <code class="docutils literal notranslate"><span class="pre">info</span></code> command to analyze the rules
loaded into RDFox. First, we create a datastore and import the rules specified
in the 6 completed Datalog files from the demo as follows.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dstore create f1
active f1
import rules/r1.dlog \
       rules/r2.dlog \
       rules/r3.dlog \
       rules/r4-completed.dlog \
       rules/r5.dlog \
       rules/r6-completed.dlog
</pre></div>
</div>
<p>To see an overview of the rules that we have imported as a result of the above
operations, we can simply issue the following <code class="docutils literal notranslate"><span class="pre">info</span></code> command.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>info rulestats
</pre></div>
</div>
<p>The command will produce the following table.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Producing rule statistics; rules will not be printed.
================================ RULES STATISTICS ================================
Component    Nonrecursive rules    Recursive rules    Total rules
        1                     3                  0              3
        2                     2                  0              2
        3                     1                  0              1
----------------------------------------------------------------------------------
Total:                        6                  0              6
==================================================================================
</pre></div>
</div>
<p>One can observe that the current datastore contains a total of 13 rules.
Furthermore, the rules have been partitioned internally into four components
according to how they <strong>depend on</strong> each other: rules in components with higher
indexes only depend on rules in components with lower indexes. Intuitively, a
rule <code class="docutils literal notranslate"><span class="pre">r1</span></code> depends on a rule <code class="docutils literal notranslate"><span class="pre">r2</span></code>, if facts matching a head atom in <code class="docutils literal notranslate"><span class="pre">r2</span></code>
also match a body atom in <code class="docutils literal notranslate"><span class="pre">r1</span></code>.  In this example, the component with index
<code class="docutils literal notranslate"><span class="pre">0</span></code> contains six <strong>recursive</strong> rules, i.e. rules that depend on each other.
The remaining components contain rules that are <strong>non-recursive</strong>, i.e. they
only depend on rules from components with lower indexes.</p>
<p>In addition to the above statistics, one can also list the rules in the current
datastore grouped by components. To this end, we can simply issue the following
command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>info rulestats print-rules
</pre></div>
</div>
<p>which will produce the following output for the component with index <code class="docutils literal notranslate"><span class="pre">1</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...
----------------------------------------------------------------------------------
-- COMPONENT:          1
-- NONRECURSIVE RULES: 3
-- RECURSIVE RULES:    0
**********************************************************************************
** BODY SIZE:          1
** NONRECURSIVE RULES: 3

&lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver,?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result,?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result,?driver] .
&lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver,?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result,?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result,?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result,?positionOrder], FILTER(?positionOrder &lt; 4) .
&lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver,?raceWinCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/result_driver&gt;[?result,?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result,1] ON ?driver BIND COUNT(?result) AS ?raceWinCount) .
----------------------------------------------------------------------------------
...
</pre></div>
</div>
</div>
<div class="section" id="using-reasoning-monitors-in-rdfox">
<h3><span class="section-number">10.9.2. </span>Using Reasoning Monitors in RDFox<a class="headerlink" href="#using-reasoning-monitors-in-rdfox" title="Permalink to this headline">¶</a></h3>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">info</span></code> command, which allows users to inspect the rules
currently loaded into a datastore, RDFox also provides a number of mechanisms
for monitoring the reasoning process every time it takes place. This is
achieved using <strong>reasoning monitors</strong>, some of which we will describe next.</p>
<div class="admonition warning">
<p class="admonition-title">Warning</p>
<p><strong>Performance considerations:</strong> The use of reasoning monitors will introduce
an overhead during reasoning that depends on the type of monitor. Their use
should, therefore, be considered carefully in use cases and workflows in
which reasoning performance is critical.</p>
</div>
<div class="section" id="the-summary-reasoning-monitor">
<h4><span class="section-number">10.9.2.1. </span>The Summary Reasoning Monitor<a class="headerlink" href="#the-summary-reasoning-monitor" title="Permalink to this headline">¶</a></h4>
<p>The summary reasoning monitor provides a short summary every time reasoning
takes place.</p>
<p>Let us create a new datastore called <code class="docutils literal notranslate"><span class="pre">f1-summary</span></code> and load the rules as
before.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dstore create f1-summary
active f1-summary
import rules/r1.dlog \
       rules/r2.dlog \
       rules/r3.dlog \
       rules/r4-completed.dlog \
       rules/r5.dlog \
       rules/r6-completed.dlog
</pre></div>
</div>
<p>To activate the summary reasoning monitor, we use the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set reason.monitor summary
</pre></div>
</div>
<p>If we now import the dataset <code class="docutils literal notranslate"><span class="pre">2021-22.ttl.zip</span></code> using the following command,</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import data/2021-22.ttl.zip
</pre></div>
</div>
<p>the summary reasoning monitor will produce the following output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>...
# Reasoning Summary Monitor Started
Evaluating rules.
Rules will be processed by strata.
Reasoning time:      0.016000 s.
--------------------------------------------------------------------------
Table           |  Entries           |  Explicit          |  All
--------------------------------------------------------------------------
DefaultTriples  |  26,881 -&gt; 29,441  |  14,820 -&gt; 14,820  |  0 -&gt; 15,759
Quads           |       1 -&gt;      1  |       0 -&gt;      0  |  0 -&gt;      0
--------------------------------------------------------------------------
# Reasoning Summary Monitor Finished
...
</pre></div>
</div>
<p>The output contains information about how the rules are processed and the
amount of time that the reasoning takes. The output also contains a table with
reasoning related information about each tuple table. The column labeled
<strong>Explicit</strong> tells us the number of facts that were explicitly given in the
data file. In turn the column labeled <strong>All</strong> indicates the total number of
facts in the store after reasoning, i.e. including the facts inferred using the
rules. In our case, this means that the datastore currently contains 8,899
facts of which 539 were derived through rule applications. The column <strong>Table</strong>
indicates the name of each tuple table in the store. In this case, we just have
the default triple table, but in other cases we may also have other tuple
tables such as those obtained from named graphs.  Each different tuple table
will have different numbers of explicit and derived facts. Finally, the column
labeled <strong>Entries</strong> indicates the total number of memory slots that were
reserved by different threads during reasoning; this number can be larger than
the total number of facts in the system as some of these slots may not have
been used to store a fact.</p>
<p>Now, let us update the content of our datastore by adding the data in
<code class="docutils literal notranslate"><span class="pre">upTo2020.ttl.zip</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import data/upTo2020.ttl.zip
</pre></div>
</div>
<p>The update will trigger another round of reasoning, for which the reasoning
monitor will produce the following output.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Reasoning Summary Monitor Started
Evaluating rules incrementally.
Rules will be processed by strata.
Maximum depth of backward chaining is unbounded.
Reasoning time:      1.280000 s.
-------------------------------------------------------------------------------------------
Table           |  Entries                 |  Explicit             |  All
-------------------------------------------------------------------------------------------
DefaultTriples  |  4,720,641 -&gt; 4,748,801  |  14,820 -&gt; 4,710,491  |  15,759 -&gt; 4,740,705
Quads           |          1 -&gt;         1  |       0 -&gt;         0  |       0 -&gt;         0
-------------------------------------------------------------------------------------------
# Reasoning Summary Monitor Finished
</pre></div>
</div>
<p>The user is informed that this update will be handled using incremental
reasoning. Additionally, the counts of the number of entries, explicit facts
and overall facts have been updated accordingly, with reasoning now responsible
for the derivation of ~30k non-explicitly stated facts.</p>
<p><strong>Performance considerations:</strong> The summary reasoning monitor has little effect
on performance of reasoning. The main overhead is introduced in the statistics
gathering steps immediately before and immediately after reasoning takes place.</p>
</div>
<div class="section" id="the-reasoning-profiler">
<h4><span class="section-number">10.9.2.2. </span>The Reasoning Profiler<a class="headerlink" href="#the-reasoning-profiler" title="Permalink to this headline">¶</a></h4>
<p>In this section we describe the <strong>reasoning profiler</strong>: a reasoning monitor
that allows users to investigate the performance of individual rules.</p>
<p>We begin by creating a data store <code class="docutils literal notranslate"><span class="pre">f1-profile</span></code> and importing our set of rules
as before.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>dstore create f1-profile
active f1-profile
import rules/r1.dlog \
       rules/r2.dlog \
       rules/r3.dlog \
       rules/r4-completed.dlog \
       rules/r5.dlog \
       rules/r6-completed.dlog
</pre></div>
</div>
<p>We activate the reasoning profiler using the following command:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set reason.monitor profile
</pre></div>
</div>
<p>Next, we import the data from the file <code class="docutils literal notranslate"><span class="pre">upTo2020.ttl.zip</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import data/upTo2020.ttl.zip
</pre></div>
</div>
<p>As a result, the reasoning monitor will produce the following output at the end
of reasoning.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Reasoning Profiler Started
## Final report after 0 seconds

+-----------------------------------------------------------------------------------------------------------------------------
|  #    Reasoning    Sample      Rule Body      Iterator    Rule Body   Fresh Facts    Rule of
|         Phase      Count    Match Attempts   Operations    Matches      Produced    Head Atom
+-----------------------------------------------------------------------------------------------------------------------------
|   1      Mat       11            24.6 k        203.1 k       3.0 k        3.0 k      (0) &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result, ?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, ?positionOrder], FILTER(?positionOrder &lt; 4) .
|   2      Mat       11           854              5.5 k     643          643          (0) &lt;https://rdfox.com/examples/f1/DriverWithoutPodiums&gt;[?driver] :- &lt;https://rdfox.com/examples/f1/driver&gt;[?driver], NOT EXISTS ?race IN &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] .
|   3      Mat        1            24.6 k        147.7 k      24.6 k       24.5 k      (0) &lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result, ?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver] .
|   4      Mat        1           847              3.8 k     108          108          (0) &lt;https://rdfox.com/examples/f1/hasWinPercentage&gt;[?driver, ?percentage] :- &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount], &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount], BIND(?raceWinCount / ?raceCount AS ?percentage) .
|   5      Mat        0             1             25.3 k     847          847          (0) &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] ON ?driver BIND COUNT(?race) AS ?raceCount) .
|   6      Mat        0             1              4.1 k     108          108          (0) &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, 1] ON ?driver BIND COUNT(?result) AS ?raceWinCount) .
+-----------------------------------------------------------------------------------------------------------------------------

# Reasoning Profiler Finished
</pre></div>
</div>
<p>The table contains statistics about rule evaluation. Reasoning in RDFox is a
complex process which is broken down into multiple phases. The reasoning that
takes place the first time data is added to the system is called <em>initial
materialization</em> and it consists of a single phase denoted as <code class="docutils literal notranslate"><span class="pre">Mat</span></code>. The
column <code class="docutils literal notranslate"><span class="pre">Sample</span> <span class="pre">Count</span></code> contains an indicator of how long it took to evaluate
a rule. The column <code class="docutils literal notranslate"><span class="pre">Rule</span> <span class="pre">Body</span> <span class="pre">Match</span> <span class="pre">Attempts</span></code> indicates how often a rule body
evaluation has been triggered. This typically equals the number of times a tuple
in the data matches the rule body, with the exception of aggregate rules (e.g.
rules 3 and 6), which are evaluated as queries, and are hence triggered once.
Similar to query evaluation, rule body atoms are compiled down to iterators,
which are opened and advanced to produce the rule instantiations, i.e full rule
body matches. The number of operations performed on the iterators of each rule
to produce those matches is given in column <code class="docutils literal notranslate"><span class="pre">Iterator</span> <span class="pre">Operations</span></code>. The number
of times the body of a rule was fully matched against the data is given in
column <code class="docutils literal notranslate"><span class="pre">Rule</span> <span class="pre">Body</span> <span class="pre">Matches</span></code>. Finally,  column <code class="docutils literal notranslate"><span class="pre">Fresh</span> <span class="pre">Facts</span> <span class="pre">Produced</span></code> reports
how many new facts were produced by each head atom of a rule. In our example,
rules have only one head atom, so for every rule, we have a single line with head
atom index <code class="docutils literal notranslate"><span class="pre">(0)</span></code>. The order of rules within the table reflects the number of
operations involved in their evaluation: rules with higher number of operations
are reported first.</p>
<p>Next let us inspect the output of the reasoning profiler when incremental
reasoning takes place. To this end we add the data in the file
<code class="docutils literal notranslate"><span class="pre">2021-22.ttl.zip</span></code>.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import data/2021-22.ttl.zip
</pre></div>
</div>
<p>The report looks much more involved, which is indicative of the complexity of
the algorithms used during incremental reasoning.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Reasoning Profiler Started
## Final report after 0 seconds

+-----------------------------------------------------------------------------------------------------------------------------
|  #    Reasoning    Sample      Rule Body      Iterator    Rule Body   Fresh Facts    Rule of
|         Phase      Count    Match Attempts   Operations    Matches      Produced    Head Atom
+-----------------------------------------------------------------------------------------------------------------------------
|   1   Addition      0             2.3 k         12.9 k     117          117          (0) &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result, ?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, ?positionOrder], FILTER(?positionOrder &lt; 4) .
|   2   Addition      0             1.5 k          7.8 k     780          780          (0) &lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result, ?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver] .
|   3   Addition      0            29              3.8 k      29           29          (0) &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] ON ?driver BIND COUNT(?race) AS ?raceCount) .
|   4   BwdChain      0            22              3.4 k       0            0          (0) &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] ON ?driver BIND COUNT(?race) AS ?raceCount) .
|   5   Deletion      0             0              3.3 k       0
|   6   Deletion      0           117              2.0 k      10            4          (0) &lt;https://rdfox.com/examples/f1/DriverWithoutPodiums&gt;[?driver] :- &lt;https://rdfox.com/examples/f1/driver&gt;[?driver], NOT EXISTS ?race IN &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] .
|   7   Deletion      0            27              2.8 k      21           21          (0) &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/hasRacedIn&gt;[?driver, ?race] ON ?driver BIND COUNT(?race) AS ?raceCount) .
|   8   Addition      0             7              2.7 k       7            7          (0) &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, 1] ON ?driver BIND COUNT(?result) AS ?raceWinCount) .
|   9   Deletion      0             7              2.2 k       4            4          (0) &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, 1] ON ?driver BIND COUNT(?result) AS ?raceWinCount) .
|  10   BwdChain      0             4              1.9 k       0            0          (0) &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount] :- AGGREGATE(&lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, 1] ON ?driver BIND COUNT(?result) AS ?raceWinCount) .
|  11   Addition      0            35            188          12           12          (0) &lt;https://rdfox.com/examples/f1/hasWinPercentage&gt;[?driver, ?percentage] :- &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount], &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount], BIND(?raceWinCount / ?raceCount AS ?percentage) .
|  12   Deletion      0            26            140           9            9          (0) &lt;https://rdfox.com/examples/f1/hasWinPercentage&gt;[?driver, ?percentage] :- &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount], &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount], BIND(?raceWinCount / ?raceCount AS ?percentage) .
|  13   BwdChain      0             9             18           0            0          (0) &lt;https://rdfox.com/examples/f1/hasWinPercentage&gt;[?driver, ?percentage] :- &lt;https://rdfox.com/examples/f1/hasRaceCount&gt;[?driver, ?raceCount], &lt;https://rdfox.com/examples/f1/hasRaceWinCount&gt;[?driver, ?raceWinCount], BIND(?raceWinCount / ?raceCount AS ?percentage) .
|  14   BwdChain      0             4             12           0            0          (0) &lt;https://rdfox.com/examples/f1/DriverWithoutPodiums&gt;[?driver] :- &lt;https://rdfox.com/examples/f1/driver&gt;[?driver], NOT EXISTS ?race IN &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] .
|  15   Deletion      0             0             26           0            0          (0) &lt;https://rdfox.com/examples/f1/hasPodiumInRace&gt;[?driver, ?race] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?result, ?race], &lt;https://rdfox.com/examples/f1/result_driver&gt;[?result, ?driver], &lt;https://rdfox.com/examples/f1/result_positionOrder&gt;[?result, ?positionOrder], FILTER(?positionOrder &lt; 4) .
+-----------------------------------------------------------------------------------------------------------------------------

# Reasoning Profiler Finished
</pre></div>
</div>
<p>First note that, in contrast to initial materialization, incremental
reasoning has multiple phases: e.g. <code class="docutils literal notranslate"><span class="pre">Addition</span></code>, <code class="docutils literal notranslate"><span class="pre">Deletion</span></code>, and
<code class="docutils literal notranslate"><span class="pre">BwdChain</span></code>.  Furthermore, each rule may take part in different phases, and
relevant statistics for each of the phases are given separately. Finally, note
the presence of a <em>deletion phase</em>, responsible for the deletion of facts, and
that of a <em>backward chaining phase</em>, responsible for the reproving of deleted
facts. These take place despite the fact that the operation that we are
performing is that of data addition (<code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">2021-22.ttl.zip</span></code>). The reason for
this is that the addition of facts could outdate facts derived directly or
indirectly by rules with aggregation or negation.</p>
<p>Next, let us inspect the output of the reasoning profiler when new rules are
added to the system. To this end, let us add the ontology to the datastore.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>import axioms/axioms.ttl
importaxioms
</pre></div>
</div>
<p>The reasoning profiler produces the following report.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Reasoning Profiler Started
## Final report after 0 seconds

+-----------------------------------------------------------------------------------------------------------------------------
|  #    Reasoning    Sample      Rule Body      Iterator    Rule Body   Fresh Facts    Rule of
|         Phase      Count    Match Attempts   Operations    Matches      Produced    Head Atom
+-----------------------------------------------------------------------------------------------------------------------------
|   1    RuleAdd     23             1            514.5 k     514.5 k      514.5 k      (0) &lt;https://rdfox.com/examples/f1/driver_lapTime&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/lapTime_driver&gt;[?Y, ?X] .
|   2    RuleAdd     23             1            514.5 k     514.5 k      514.5 k      (0) &lt;https://rdfox.com/examples/f1/race_lapTime&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/lapTime_race&gt;[?Y, ?X] .
|   3   Addition     12           514.5 k          1.0 M     514.5 k      514.5 k      (0) &lt;https://rdfox.com/examples/f1/lapTime_driver&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/driver_lapTime&gt;[?Y, ?X] .
|   4   Addition     12           514.5 k          1.0 M     514.5 k      514.5 k      (0) &lt;https://rdfox.com/examples/f1/lapTime_race&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/race_lapTime&gt;[?Y, ?X] .
|   5    RuleAdd     12             1              1.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!&lt;internal:in&gt;(DATATYPE(?X1), xsd:byte, xsd:int, xsd:integer, xsd:long, xsd:negativeInteger, xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:short, xsd:unsignedByte, xsd:unsignedInt, xsd:unsignedLong, xsd:unsignedShort) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_position&gt;[?X, ?X1] .
|   6    RuleAdd     11             1              1.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!&lt;internal:in&gt;(DATATYPE(?X1), xsd:byte, xsd:int, xsd:integer, xsd:long, xsd:negativeInteger, xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:short, xsd:unsignedByte, xsd:unsignedInt, xsd:unsignedLong, xsd:unsignedShort) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_lap&gt;[?X, ?X1] .
|   7    RuleAdd     11             1              1.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!&lt;internal:in&gt;(DATATYPE(?X1), xsd:byte, xsd:int, xsd:integer, xsd:long, xsd:negativeInteger, xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:short, xsd:unsignedByte, xsd:unsignedInt, xsd:unsignedLong, xsd:unsignedShort) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_milliseconds&gt;[?X, ?X1] .
|   8    RuleAdd     10             1              1.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!(DATATYPE(?X1) = xsd:string) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_time&gt;[?X, ?X1] .
|   9    RuleAdd      9             1            514.5 k     514.5 k      109.4 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_milliseconds&gt;[?X, ?X1] .
|  10    RuleAdd      9             1            514.5 k     514.5 k      108.3 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_lap&gt;[?X, ?X1] .
|  11    RuleAdd      9             1            514.5 k     514.5 k       83.7 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_position&gt;[?X, ?X1] .
|  12    RuleAdd      9             1            514.5 k     514.5 k       78.2 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_time&gt;[?X, ?X1] .
|  13    RuleAdd      9             1            514.5 k     514.5 k      101.4 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_driver&gt;[?X, ?X1] .
|  14    RuleAdd      9             1            514.5 k     514.5 k       33.3 k      (0) &lt;https://rdfox.com/examples/f1/lapTime&gt;[?X] :- &lt;https://rdfox.com/examples/f1/lapTime_race&gt;[?X, ?X1] .
|                                                                           0          (0) &lt;https://rdfox.com/examples/f1/race&gt;[?X1] :- &lt;https://rdfox.com/examples/f1/lapTime_race&gt;[?X, ?X1] .
|  15   Addition      6            82            164          82            0          (0) &lt;https://rdfox.com/examples/f1/has_relative&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/has_relative&gt;[?Y, ?X] .
|  16   Addition      4            26.4 k        107.9 k       1.0 k        0          (0) &lt;https://rdfox.com/examples/f1/RaceWinner&gt;[?X] :- &lt;https://rdfox.com/examples/f1/driver_result&gt;[?X, ?X1], &lt;https://rdfox.com/examples/f1/Win&gt;[?X1] .
|  17    RuleAdd      2             1             33.4 k      33.4 k       33.4 k      (0) &lt;https://rdfox.com/examples/f1/driver_driverStanding&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/driverStanding_driver&gt;[?Y, ?X] .
|  18    RuleAdd      2             1             25.4 k      25.4 k       25.4 k      (0) &lt;https://rdfox.com/examples/f1/race_result&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/result_race&gt;[?Y, ?X] .
|  19    RuleAdd      2             1             25.4 k      25.4 k       25.4 k      (0) &lt;https://rdfox.com/examples/f1/constructor_result&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/result_constructor&gt;[?Y, ?X] .
|  20    RuleAdd      2             1             25.4 k      25.4 k       25.4 k      (0) &lt;https://rdfox.com/examples/f1/status_result&gt;[?X, ?Y] :- &lt;https://rdfox.com/examples/f1/result_status&gt;[?Y, ?X] .
+-----------------------------------------------------------------------------------------------------------------------------

# Reasoning Profiler Finished
</pre></div>
</div>
<p>Note that the axioms in the ontology have been translated into rules. The
initial handling of added rules is done in the <em>rule addition</em> phase of
incremental reasoning. Phases <code class="docutils literal notranslate"><span class="pre">deletion</span></code> and <code class="docutils literal notranslate"><span class="pre">rule</span> <span class="pre">deletion</span></code> are
responsible for the handling of fact and rule deletion respectively.</p>
<p>So far, we have used the reasoning profiler to view runtime statistics about
rules. In some workflows it may be beneficial to see runtime statistics about
rule evaluation on <em>rule plan level</em>. This is particularly the case when one
is optimizing reasoning performance.</p>
<p>To specify that the reasoning profiler should collect information on rule plan
level, we use the following command.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set reason.profiler.log-plans true
</pre></div>
</div>
<p>Since the output for plans is quite verbose, we also change the limit on the
number entries that are printed on the screen from the default value of <code class="docutils literal notranslate"><span class="pre">20</span></code>
to <code class="docutils literal notranslate"><span class="pre">2</span></code>. Note that the latter only affects the number of entries that are
being reported, rather than the number of entries for which statistics are
being collected.
:::::::::::::::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set reason.profiler.entries 2
</pre></div>
</div>
<p>We can now trigger reasoning using the <code class="docutils literal notranslate"><span class="pre">remat</span></code> command, which will perform
initial materialisation over the whole dataset with the rules currently loaded
in the system.
:::::::::::::</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>remat
</pre></div>
</div>
<p>The profiler now outputs the following report.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span># Reasoning Profiler Started
## Final report after 0 seconds

#1

   Rule Info
   +-----------------------------------------------------------------------------------------------------------------------------------------
   | Reasoning    Sample      Rule Body      Iterator    Rule Body   Fresh Facts    Rule of
   |   Phase      Count    Match Attempts   Operations    Matches      Produced    Head Atom
   +-----------------------------------------------------------------------------------------------------------------------------------------
   |    Mat       17           514.5 k          2.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!(DATATYPE(?X1) = xsd:string) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_time&gt;[?X, ?X1] .
   +-----------------------------------------------------------------------------------------------------------------------------------------

   Plan Info
   +-----------------------------------------------------------------------------------------------------------------------------------------
   | Sample Count   Iterator Open   Iterator Advance    Plan Node
   +-----------------------------------------------------------------------------------------------------------------------------------------
   |                                                      PROJECT ?X1                                                                        {           --&gt;    ?X1 }
   |            2         514,592                  0          CONJUNCTION                                                                    {           --&gt;    ?X ?X1 }    NestedIndexLoopJoinIterator
   |            1         514,592            514,592              DELTA [?X, &lt;https://rdfox.com/examples/f1/lapTime_time&gt;, ?X1]              {           --&gt;    ?X ?X1 }    DeltaAtomIterator
   |           12         514,592                  0              FILTER ATOM !(DATATYPE(?X1) = xsd:string) || isIRI(?X1) || isBlank(?X1)    { ?X ?X1    --&gt;    ?X ?X1 }    FilterAtomIterator
   +-----------------------------------------------------------------------------------------------------------------------------------------

#2

   Rule Info
   +-----------------------------------------------------------------------------------------------------------------------------------------
   | Reasoning    Sample      Rule Body      Iterator    Rule Body   Fresh Facts    Rule of
   |   Phase      Count    Match Attempts   Operations    Matches      Produced    Head Atom
   +-----------------------------------------------------------------------------------------------------------------------------------------
   |    Mat       16           514.5 k          2.0 M       0            0          (0) owl:Nothing[?X1] :- FILTER(!&lt;internal:in&gt;(DATATYPE(?X1), xsd:byte, xsd:int, xsd:integer, xsd:long, xsd:negativeInteger, xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:short, xsd:unsignedByte, xsd:unsignedInt, xsd:unsignedLong, xsd:unsignedShort) || isIRI(?X1) || isBlank(?X1)), &lt;https://rdfox.com/examples/f1/lapTime_lap&gt;[?X, ?X1] .
   +-----------------------------------------------------------------------------------------------------------------------------------------

   Plan Info
   +-----------------------------------------------------------------------------------------------------------------------------------------
   | Sample Count   Iterator Open   Iterator Advance    Plan Node
   +-----------------------------------------------------------------------------------------------------------------------------------------
   |                                                      PROJECT ?X1                                                                                                                                                                                                                                                                                               {           --&gt;    ?X1 }
   |            0         514,592                  0          CONJUNCTION                                                                                                                                                                                                                                                                                           {           --&gt;    ?X ?X1 }    NestedIndexLoopJoinIterator
   |            2         514,592            514,592              DELTA [?X, &lt;https://rdfox.com/examples/f1/lapTime_lap&gt;, ?X1]                                                                                                                                                                                                                                      {           --&gt;    ?X ?X1 }    DeltaAtomIterator
   |           12         514,592                  0              FILTER ATOM !&lt;internal:in&gt;(DATATYPE(?X1), xsd:byte, xsd:int, xsd:integer, xsd:long, xsd:negativeInteger, xsd:nonNegativeInteger, xsd:nonPositiveInteger, xsd:positiveInteger, xsd:short, xsd:unsignedByte, xsd:unsignedInt, xsd:unsignedLong, xsd:unsignedShort) || isIRI(?X1) || isBlank(?X1)    { ?X ?X1    --&gt;    ?X ?X1 }    FilterAtomIterator
   +-----------------------------------------------------------------------------------------------------------------------------------------

# Reasoning Profiler Finished
</pre></div>
</div>
<p>When set up in this way, the reasoning profiler reports statistics on rule plan
level. Details on how to interpret query/rule plans and runtime statistic
associated with them can be found in <a class="reference internal" href="querying.html#query-monitoring"><span class="std std-ref">Monitoring Query Evaluation</span></a>.</p>
<p>In heavy workloads in which reasoning takes a very long time, it may be useful
to have statistics reports printed on a regular basis. This can be done using
the <code class="docutils literal notranslate"><span class="pre">log-frequency</span></code> shell variable. For example, the following command will
ensure that the reasoning profiler outputs its statistics reports every <code class="docutils literal notranslate"><span class="pre">10s</span></code>
as well as at the end of reasoning.</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set log-frequency 10
</pre></div>
</div>
<p><strong>Performance considerations:</strong> The reasoning profiler may have a significant
impact on the reasoning performance. This is particularly true when statistics
about rule plans are collected, in which case reasoning time may even double.</p>
</div>
</div>
</div>
<div class="section" id="querying-the-explicitly-given-data">
<h2><span class="section-number">10.10. </span>Querying the Explicitly given Data<a class="headerlink" href="#querying-the-explicitly-given-data" title="Permalink to this headline">¶</a></h2>
<p>After reasoning, RDFox will by default answer all SPARQL queries with respect
to the obtained materialization. For instance, suppose that we have a data
store with fact <code class="docutils literal notranslate"><span class="pre">:a</span> <span class="pre">rdf:type</span> <span class="pre">:A</span></code> and the following rules:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>[?x, rdf:type, :B] :- [?x, rdf:type, :A] .

[?x, rdf:type, :C] :- [?x, rdf:type, :B] .

[?x, rdf:type, :D] :- [?x, rdf:type, :B] .

[?x, rdf:type, :A] :- [?x, rdf:type, :D] .
</pre></div>
</div>
<p>The materialization will contain the following facts, where three of them have
been derived and only fact <code class="docutils literal notranslate"><span class="pre">:a</span> <span class="pre">rdf:type</span> <span class="pre">:A</span></code> was originally in the data:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>:a rdf:type :A .
:a rdf:type :B .
:a rdf:type :C .
:a rdf:type :D .
</pre></div>
</div>
<p>If we issue a query</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SELECT ?x WHERE { ?x rdf:type :D }
</pre></div>
</div>
<p>we will obtain <code class="docutils literal notranslate"><span class="pre">:a</span></code> as a result.</p>
<p>In RDFox it is possible to query only the explicit data even after
materialization has been performed. For this, we can use the shell command</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>set query.fact-domain explicit
</pre></div>
</div>
<p>If we then issue the previous query again we will obtain the empty answer as a
result.</p>
</div>
</div>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="querying.html" class="btn btn-neutral float-left" title="9. Querying" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="transactions.html" class="btn btn-neutral float-right" title="11. Transactions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2025, Oxford Semantic Technologies Ltd.</p>
  </div>

  
     

    <!-- consent banner, edit cookies button and HS cookies -->
    <!-- Start of HubSpot Embed Code -->
    <script type="text/javascript" id="hs-script-loader" async defer src="//js.hs-scripts.com/6485449.js"></script>
    <!-- End of HubSpot Embed Code -->

    <!-- Cookies settings button -->
    <!-- Start of HubSpot code snippet -->
    <button type="button" id="hs_show_banner_button"
    style="background-color: #fff; border: 1px solid #2980b9;
        border-radius: 3px; padding: 5px 8px; text-decoration: none; color: #2980b9;
        font-family: inherit; font-size: 80%; font-weight: normal; line-height: inherit;
        text-align: left; text-shadow: none;"
    onClick="(function(){
            var _hsp = window._hsp = window._hsp || [];
            _hsp.push(['showBanner']);
        })()"
    >
    Cookie Settings
    </button>
    <style>
        @media all and (min-width:1160px){
            .hs-cookie-notification-position-bottom {width: 80%!important;}
        }
    </style>
    <!-- End of HubSpot code snippet -->
    <!-- consent banner, edit cookies button and HS cookies -->

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>